#if (${PACKAGE_NAME} && ${PACKAGE_NAME} != "")package ${PACKAGE_NAME};#end





import java.util.Comparator;

#parse("File Header.java")

import com.google.auto.value.AutoValue;


/**
 * class-value nonmutable with generics
 * !CHANGE_ME_DESCRIPTION!
 *
 * inner comments: ${uncomment1}  

*   ${T1} ${T2} ${T3} ${T4} ${T5} ${T6} ${T7} ${T8} ${T9}
 *
*   @author     wilmer
*   @version    1.0
*   @since      1.0 wilmer draft
 *
 
 	1) чтобы нельзя было отнаследовать и затереть данные подкласса ВЫБРАН ВАРИАНТ Б)
		вариант а) сделать класс final
		вариант  б) закрыть ВСЕ конструкторы и получать объекты только фабрикой
 
     a) This abstract class for autogenerated Google's AutoValue 
     https://github.com/google/auto/blob/master/value/userguide/index.md

     b) IDE autogenerated Guava ComparisonChain

     - You can use mutable variant of the class (companien class) for batch operations
 
 
 	 8) копирующие фабрики: для немутабельных классов нет смысла поддерживать копирование объектов, поскольку копии будут фактически неотличимы от оригинала.
	   - для немутабельных классов статические методы генерации копии имеют смысл, если получают на вход  параметр более общего интерфейса и мутабельный аргумент (см как в коллекциях Java)
	   - они называются conversion constructors / conversion factories 



 Every constructor/fabric can raise the exceptions:
 @throws NullPointerException if argument nullable
 @throws IllegalArgumentException if argument empty 


 */
 
 
 #if(${uncomment1}==1)
 //<editor-fold desc=".">
 /*
    
    1) Click right mouse button: generate static fabric - create
    
    2) Click right mouse button: generate autovalue builder
 
    [3] Если нужно то добавить T1_extends_String в объявления класса-value и класса-builde
        также добавить это во все static методы: create и builder
  
 
    3) uncoment toBuild 
 
    4) uncoment autoBuild and build
 
    5) if you have references to mutable object you should use properties - immutable analogs OR defencive copying
    
     5) refactor and rename properties
    
    6) compime maven goal and autogenerate auto-value class
    
    
    
 
    0) Как сделать рефакторинг: вынести AutoValue наверх
        1) Убрать abstract и аннотации_auto_value с верхнего класса
        2) Удалить autoValue класс целиком
        3) Удалить abstract builder целиком и сделать конкретный билдер как public
        4) Удалить слово autovalue
 
  
 
 
    b) тк должна быть одна точка входа, одна точка контакта со сгенерированным кодом
       то поместите все проверки в метод build() билдера
       
            assertForValidProperties_();
            assertForConsistencyProperties_();
    
    b) если хочу исправить параметр в билдере
            - поместить в билдер поля
            - проверить их в билдере
            - можно заново их модифицировать, если нужно

        //имена должны совпадать с теми что в немутабельном классе, но только package доступа
        abstract ${T1} item1();
        abstract ${T2} item2();
        
        public Animal build() {
          if (!name().isPresent()) {
            setName(numberOfLegs() + "-legged creature");
          }
          return autoBuild(); }
    
    
    c) аннотируйте @Nullable параметры метода create для допуска нулевых аргументов
    
        public static Foo create(@Nullable Bar bar) {

    
    d) для игнориррования методов, пометить их как final
       для игнорирования свойств, пометить их private

        private String ignoredProperty;
        final String ignoredProperty() {    

        
    e) если нужно закешировать свойство то пометить его аннотацией

        @Memoized
        String derivedProperty() {
        return someFunctionOf(barProperty()); }

      
    f) если нужно закешировать hashCode то после IDE генерации методов, нужно добавить нижеследующее
    
        @Memoized
        @Override
        public abstract int hashCode();
        @Memoized
        @Override
        public abstract String toString();

      
        
	j) нет конструкторов, только статик фабрики
	
	h) если нужны аннотации, то поместить их ниже @AutoValue.CopyAnnotations

    g) дефолтные значения свойств можно выставить в методе builder()

        static Builder builder() {
        return new AutoValue_Animal.Builder().setNumberOfLegs(4); }

    
   e) как сделать withName метод
  
     public Animal withName(String name) {
     return toBuilder().setName(name).build();}

     
   z) для свойств коллекций можно объявить параметр любого типа, что и принимает ImmutableList.copyOf 

   		public abstract Builder item2( final ImmutableList< String > item2 );
		public abstract Builder item2( final List< String > item2 );
		public abstract Builder item2( final Collection< ? extends String > item2 );
		public abstract Builder item2( final Iterable< ? extends String > item2 );
		public abstract Builder item2( final String ... item2 );

     
   e) чтобы сделать билдер еще и для свойства коллекции
      Animal dog = Animal.builder()
      .setName("dog")
      .setNumberOfLegs(4)
      .addCountry("Guam")
      .addCountry("Laos")
      .build();

        public abstract ImmutableSet.Builder<String> countriesBuilder();
        public Builder addCountry(String value) {
            countriesBuilder().add(value);
            return this; }
        
 */
//</editor-fold>
#end


@AutoValue
@AutoValue.CopyAnnotations
@Immutable
public abstract class ${NAME} <
    #if (${T1} != "")   T1 #end
    #if (${T2} != "") , T2 #end
    #if (${T3} != "") , T3 #end
    #if (${T4} != "") , T4 #end
    #if (${T5} != "") , T5 #end
    #if (${T6} != "") , T6 #end
    #if (${T7} != "") , T7 #end
    #if (${T8} != "") , T8 #end
    #if (${T9} != "") , T9 #end
>	
////implements Comparable< ${NAME}  > 
	{
	
    #parse("log.java")

  
	
	


#if (${T1} != "")
	/**
	 * get some property
	 *
	 * <pre>{@code
	 *
	 * example 1
	 *
	 *           String v_stringTwo=v_objectTwo.item1();
	 *
	 *
	 * }</pre>
	 *
	 * @return tuple item
	 */
	public abstract T1 item1();	
#end

#if (${T2} != "")
	/**
	 * get some property
	 *
	 * <pre>{@code
	 *
	 * example 1
	 *
	 *           String v_stringTwo=v_objectTwo.item2();
	 *
	 *
	 * }</pre>
	 *
	 * @return tuple item
	 */
	public abstract T2 item2();	
#end

#if (${T3} != "")
	/**
	 * get some property
	 *
	 * <pre>{@code
	 *
	 * example 1
	 *
	 *           String v_stringTwo=v_objectTwo.item3();
	 *
	 *
	 * }</pre>
	 *
	 * @return tuple item
	 */
	public abstract T3 item3();	
#end

#if (${T4} != "")
	/**
	 * get some property
	 *
	 * <pre>{@code
	 *
	 * example 1
	 *
	 *           String v_stringTwo=v_objectTwo.item4();
	 *
	 *
	 * }</pre>
	 *
	 * @return tuple item
	 */
	public abstract T4 item4();	
#end

#if (${T5} != "")
	/**
	 * get some property
	 *
	 * <pre>{@code
	 *
	 * example 1
	 *
	 *           String v_stringTwo=v_objectTwo.item5();
	 *
	 *
	 * }</pre>
	 *
	 * @return tuple item
	 */
	public abstract T5 item5();	
#end

#if (${T6} != "")
	/**
	 * get some property
	 *
	 * <pre>{@code
	 *
	 * example 1
	 *
	 *           String v_stringTwo=v_objectTwo.item6();
	 *
	 *
	 * }</pre>
	 *
	 * @return tuple item
	 */
	public abstract T6 item6();	
#end

#if (${T7} != "")
	/**
	 * get some property
	 *
	 * <pre>{@code
	 *
	 * example 1
	 *
	 *           String v_stringTwo=v_objectTwo.item7();
	 *
	 *
	 * }</pre>
	 *
	 * @return tuple item
	 */
	public abstract T7 item7();	
#end

#if (${T8} != "")
	/**
	 * get some property
	 *
	 * <pre>{@code
	 *
	 * example 1
	 *
	 *           String v_stringTwo=v_objectTwo.item8();
	 *
	 *
	 * }</pre>
	 *
	 * @return tuple item
	 */
	public abstract T8 item8();	
#end

#if (${T9} != "")
	/**
	 * get some property
	 *
	 * <pre>{@code
	 *
	 * example 1
	 *
	 *           String v_stringTwo=v_objectTwo.item9();
	 *
	 *
	 * }</pre>
	 *
	 * @return tuple item
	 */
	public abstract T9 item9();	
#end




	
	 
	
	
    

	
	//////////////////////////////////////////////////////////////////////////////////
	//  add your own methods                              
	//////////////////////////////////////////////////////////////////////////////////
	
	
     
    	
	/**
	 * method f_method
	 *
	 *
	 * - в немутабельных классах используется функциональный подход: 
	- операции немутабельного класса могут возвращать новый немутабельный объект
	например врзвращать немутабельный объект того же класса
	 *
	 
	 
 
 *
 *  2) количество параметров должно быть не более 4-х, иначе:
 *   	- разбить метод на несколько (как например в NEW-SET-CALL для каждого параметра отдельный сетер)
 *   	- вынести группу параметров в value-класс (nested static) (helper class)
 *   	- все параметры зашить в паттерн билдер, где параметры можно присваивать по-очереди (так что билдер применим и на мутабельном объекте)
 *
	 
	 
	 * <pre>{@code
	 *
	 *
	 * example 1
	 *            - генерирую runtime ошибки программирования
	 *            - генерирую runtime ошибки выполнения метода, если метод не вернет то что должен
	 *
	 *
	 * example 2
	 *
	 *           v_obj.f_method("test");
	 *
	 * example 3
	 *
	 *           - covariance: this overrided method can return subclass unstead class:
	 *                  resultSomeSuperclass f_method()
	 *                  resultSomeSubclass   f_overrided_method()
	 *
	 *
	 * }</pre> ПОМНИ СГЕНЕРИТЬ JAVADOC MAC8+fixDocComment И УБРАТЬ ЭТОТ ТЕКСТ
	 
     @throws IllegalArgumentException if argument empty or null
	 */
	public ${NAME}<
        #if (${T1} != "")   T1 #end
        #if (${T2} != "") , T2 #end
        #if (${T3} != "") , T3 #end
        #if (${T4} != "") , T4 #end
        #if (${T5} != "") , T5 #end
        #if (${T6} != "") , T6 #end
        #if (${T7} != "") , T7 #end
        #if (${T8} != "") , T8 #end
        #if (${T9} != "") , T9 #end
        >
	 compute(@NotNull final String string )
		{
	    notBlank( string );

        #parse("methodcompute.java")
        


		return null;
		}
		
		
		/*
		
		//!! ПОМЕСТИТЬ НИЖЕСЛЕДУЮЩЕЕ В КЛАСС
		
		
		    public abstract Builder<
#if (${T1} != "")   T1 #end
#if (${T2} != "") , T2 #end
#if (${T3} != "") , T3 #end
#if (${T4} != "") , T4 #end
#if (${T5} != "") , T5 #end
#if (${T6} != "") , T6 #end
#if (${T7} != "") , T7 #end
#if (${T8} != "") , T8 #end
#if (${T9} != "") , T9 #end
        >
        toBuilder();
		
		
		
		
		
		
		
		//!!!! ПОМЕСТИТЬ НИЖЕСЛЕДУЮЩЕЕ В БИЛДЕР
		
		
		//if you want to modify property inside build()
        #if (${T1} != "")abstract T1 item1(); #end
        #if (${T2} != "")abstract T2 item2(); #end
        #if (${T3} != "")abstract T3 item3(); #end
        #if (${T4} != "")abstract T4 item4(); #end
        #if (${T5} != "")abstract T5 item5(); #end
        #if (${T6} != "")abstract T6 item6(); #end
        #if (${T7} != "")abstract T7 item7(); #end
        #if (${T8} != "")abstract T8 item8(); #end
        #if (${T9} != "")abstract T9 item9(); #end
	    
	    
 		//package access level
 		abstract ${NAME}<
            #if (${T1} != "")   T1 #end
            #if (${T2} != "") , T2 #end
            #if (${T3} != "") , T3 #end
            #if (${T4} != "") , T4 #end
            #if (${T5} != "") , T5 #end
            #if (${T6} != "") , T6 #end
            #if (${T7} != "") , T7 #end
            #if (${T8} != "") , T8 #end
            #if (${T9} != "") , T9 #end
            >
 		 autoBuild();  
		

		public ${NAME}
		    <
            #if (${T1} != "")   T1 #end
            #if (${T2} != "") , T2 #end
            #if (${T3} != "") , T3 #end
            #if (${T4} != "") , T4 #end
            #if (${T5} != "") , T5 #end
            #if (${T6} != "") , T6 #end
            #if (${T7} != "") , T7 #end
            #if (${T8} != "") , T8 #end
            #if (${T9} != "") , T9 #end
            >
		 build()
			{
			// Если item2 мутабельный то лучше не копировать(тк копию в гетере здесь сделать не получиться) а присвоить немутабельному типу
			//this.item2(deepCopyOfObject( this.item2() ,  List.class ) );

			
			
			${NAME}<
			    #if (${T1} != "")   T1 #end
                #if (${T2} != "") , T2 #end
                #if (${T3} != "") , T3 #end
                #if (${T4} != "") , T4 #end
                #if (${T5} != "") , T5 #end
                #if (${T6} != "") , T6 #end
                #if (${T7} != "") , T7 #end
                #if (${T8} != "") , T8 #end
                #if (${T9} != "") , T9 #end
                >
			 o = autoBuild();
			
			//validate property values here
		    //check fo nullness already done by AutoValue
			//#if (${T1} != "") checkNotNull( o.item1()  ); #end
            //#if (${T2} != "") checkNotNull( o.item2()  ); #end
            //#if (${T3} != "") checkNotNull( o.item3()  ); #end
            //#if (${T4} != "") checkNotNull( o.item4()  ); #end
            //#if (${T5} != "") checkNotNull( o.item5()  ); #end
            //#if (${T6} != "") checkNotNull( o.item6()  ); #end
            //#if (${T7} != "") checkNotNull( o.item7()  ); #end
            //#if (${T8} != "") checkNotNull( o.item8()  ); #end
            //#if (${T9} != "") checkNotNull( o.item9()  ); #end 
			
			return o;
			}
		
	*/
		
		
		
		
		
		
		
	}
