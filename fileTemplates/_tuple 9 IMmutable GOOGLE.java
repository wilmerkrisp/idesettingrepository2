#if (${PACKAGE_NAME} && ${PACKAGE_NAME} != "")package ${PACKAGE_NAME};#end





import java.util.Comparator;

#parse("File Header.java")

import com.google.auto.value.AutoValue;


/**<pre>
 * class-value nonmutable
 * !CHANGE_ME_DESCRIPTION!
 *
 * inner comments: ${uncomment1}  

*   ${T1} ${T2} ${T3} ${T4} ${T5} ${T6} ${T7} ${T8} ${T9}
 *

 *
 
 	1) чтобы нельзя было отнаследовать и затереть данные подкласса ВЫБРАН ВАРИАНТ Б)
		вариант а) сделать класс final
		вариант  б) закрыть ВСЕ конструкторы и получать объекты только фабрикой
 
     a) This abstract class for autogenerated Google's AutoValue 
     https://github.com/google/auto/blob/master/value/userguide/index.md

     b) IDE autogenerated Guava ComparisonChain

     - You can use mutable variant of the class (companien class) for batch operations
 
 
 	 8) копирующие фабрики: для немутабельных классов нет смысла поддерживать копирование объектов, поскольку копии будут фактически неотличимы от оригинала.
	   - для немутабельных классов статические методы генерации копии имеют смысл, если получают на вход  параметр более общего интерфейса и мутабельный аргумент (см как в коллекциях Java)
	   - они называются conversion constructors / conversion factories 

* Preconditions: 	none
* Postconditions:	none
* Side effects:		none
* Tread safety:		Immutable
 </pre>
 
 *   @author     wilmer
*   @version    1.0
*   @since      1.0 wilmer draft

  Every constructor/fabric can raise the exceptions:
 throws NullPointerException if argument nullable
 throws IllegalArgumentException if argument empty 
 
 */
 
 
 #if(${uncomment1}==1)
 //<editor-fold desc=".">
 /*
    
   
    
    1) Click right mouse button: generate static fabric - create
    
    2) Click right mouse button: generate autovalue builder
 
    3) uncoment autoBuild and build
     
    [4] если название типа свойства начиналось со слова Immutable то необходимо раскоментировать дополнительный билдер
 
    4) if you have references to mutable object you should use properties - immutable analogs OR defencive copying
    
    5) refactor and rename properties
    
    6) compime maven goal and autogenerate auto-value class
    
    
 
 
 
    0) Как сделать рефакторинг: вынести AutoValue наверх
        1) Убрать abstract и аннотации_auto_value с верхнего класса
        2) Удалить autoValue класс целиком
        3) Удалить abstract builder целиком и сделать конкретный билдер как public
        4) Удалить слово autovalue
 
 
 
 
    b) тк должна быть одна точка входа, одна точка контакта со сгенерированным кодом
       то поместите все проверки в метод build() билдера
       
            assertForValidProperties_();
            assertForConsistencyProperties_();
    
    b) если хочу исправить параметр в билдере
            - поместить в билдер поля
            - проверить их в билдере
            - можно заново их модифицировать, если нужно

        //имена должны совпадать с теми что в немутабельном классе, но только package доступа
        abstract ${T1} item1();
        abstract ${T2} item2();
        
        public Animal build() {
          if (!name().isPresent()) {
            setName(numberOfLegs() + "-legged creature");
          }
          return autoBuild(); }
    
    
    c) аннотируйте @Nullable параметры метода create для допуска нулевых аргументов
    
        public static Foo create(@Nullable Bar bar) {

    
    d) для игнориррования методов, пометить их как final
       для игнорирования свойств, пометить их private

        private String ignoredProperty;
        final String ignoredProperty() {    

        
    e) если нужно закешировать свойство то пометить его аннотацией

        @Memoized
        String derivedProperty() {
        return someFunctionOf(barProperty()); }

      
    f) если нужно закешировать hashCode то после IDE генерации методов, нужно добавить нижеследующее
    
        @Memoized
        @Override
        public abstract int hashCode();
        @Memoized
        @Override
        public abstract String toString();

      
        
	j) нет конструкторов, только статик фабрики
	
	h) если нужны аннотации, то поместить их ниже @AutoValue.CopyAnnotations

    g) дефолтные значения свойств можно выставить в методе builder()

        static Builder builder() {
        return new AutoValue_Animal.Builder().setNumberOfLegs(4); }

    
   e) как сделать withName метод
  
     public Animal withName(String name) {
     return toBuilder().setName(name).build();}

     
   z) для свойств коллекций можно объявить параметр любого типа, что и принимает ImmutableList.copyOf 

   		public abstract Builder item2( final ImmutableList< String > item2 );
		public abstract Builder item2( final List< String > item2 );
		public abstract Builder item2( final Collection< ? extends String > item2 );
		public abstract Builder item2( final Iterable< ? extends String > item2 );
		public abstract Builder item2( final String ... item2 );

     
   e) чтобы сделать билдер еще и для свойства коллекции
      Animal dog = Animal.builder()
      .setName("dog")
      .setNumberOfLegs(4)
      .addCountry("Guam")
      .addCountry("Laos")
      .build();

        public abstract ImmutableSet.Builder<String> countriesBuilder();
        public Builder addCountry(String value) {
            countriesBuilder().add(value);
            return this; }
        
 */
//</editor-fold>
#end


@AutoValue
@AutoValue.CopyAnnotations
@Immutable
public abstract class ${NAME} 	
////implements Comparable< ${NAME}  > 
	{
	
    #parse("log.java")

  
	
	


#if (${T1} != "")
	/**
	 * get some property
	 *
	 * <pre>{@code
	 *
	 * example 1
	 *
	 *           String v_stringTwo=v_objectTwo.item1();
	 *
	 *
	 * }</pre>
	 *
	 * @return tuple item
	 */
	public abstract ${T1} item1();	
#end

#if (${T2} != "")
	/**
	 * get some property
	 *
	 * <pre>{@code
	 *
	 * example 1
	 *
	 *           String v_stringTwo=v_objectTwo.item2();
	 *
	 *
	 * }</pre>
	 *
	 * @return tuple item
	 */
	public abstract ${T2} item2();	
#end

#if (${T3} != "")
	/**
	 * get some property
	 *
	 * <pre>{@code
	 *
	 * example 1
	 *
	 *           String v_stringTwo=v_objectTwo.item3();
	 *
	 *
	 * }</pre>
	 *
	 * @return tuple item
	 */
	public abstract ${T3} item3();	
#end

#if (${T4} != "")
	/**
	 * get some property
	 *
	 * <pre>{@code
	 *
	 * example 1
	 *
	 *           String v_stringTwo=v_objectTwo.item4();
	 *
	 *
	 * }</pre>
	 *
	 * @return tuple item
	 */
	public abstract ${T4} item4();	
#end

#if (${T5} != "")
	/**
	 * get some property
	 *
	 * <pre>{@code
	 *
	 * example 1
	 *
	 *           String v_stringTwo=v_objectTwo.item5();
	 *
	 *
	 * }</pre>
	 *
	 * @return tuple item
	 */
	public abstract ${T5} item5();	
#end

#if (${T6} != "")
	/**
	 * get some property
	 *
	 * <pre>{@code
	 *
	 * example 1
	 *
	 *           String v_stringTwo=v_objectTwo.item6();
	 *
	 *
	 * }</pre>
	 *
	 * @return tuple item
	 */
	public abstract ${T6} item6();	
#end

#if (${T7} != "")
	/**
	 * get some property
	 *
	 * <pre>{@code
	 *
	 * example 1
	 *
	 *           String v_stringTwo=v_objectTwo.item7();
	 *
	 *
	 * }</pre>
	 *
	 * @return tuple item
	 */
	public abstract ${T7} item7();	
#end

#if (${T8} != "")
	/**
	 * get some property
	 *
	 * <pre>{@code
	 *
	 * example 1
	 *
	 *           String v_stringTwo=v_objectTwo.item8();
	 *
	 *
	 * }</pre>
	 *
	 * @return tuple item
	 */
	public abstract ${T8} item8();	
#end

#if (${T9} != "")
	/**
	 * get some property
	 *
	 * <pre>{@code
	 *
	 * example 1
	 *
	 *           String v_stringTwo=v_objectTwo.item9();
	 *
	 *
	 * }</pre>
	 *
	 * @return tuple item
	 */
	public abstract ${T9} item9();	
#end




	
	 
	
	
 
	
	 /**
	 * get builder object
	   for autogenerater: object.toBuilder().build(); 
	 */
    public abstract Builder toBuilder();
	


	
	
    

	
	//////////////////////////////////////////////////////////////////////////////////
	//  add your own methods                              
	//////////////////////////////////////////////////////////////////////////////////
	
	
     
    	
	/**
	 * method f_method
	 *
	 *
	 * - в немутабельных классах используется функциональный подход: 
	- операции немутабельного класса могут возвращать новый немутабельный объект
	например врзвращать немутабельный объект того же класса
	 *
	 
 
 *
 *  2) количество параметров должно быть не более 4-х, иначе:
 *   	- разбить метод на несколько (как например в NEW-SET-CALL для каждого параметра отдельный сетер)
 *   	- вынести группу параметров в value-класс (nested static) (helper class)
 *   	- все параметры зашить в паттерн билдер, где параметры можно присваивать по-очереди (так что билдер применим и на мутабельном объекте)
 *
	 
	 
	 
	 * <pre>{@code
	 *
	 *
	 * example 1
	 *            - генерирую runtime ошибки программирования
	 *            - генерирую runtime ошибки выполнения метода, если метод не вернет то что должен
	 *
	 *
	 * example 2
	 *
	 *           v_obj.f_method("test");
	 *
	 * example 3
	 *
	 *           - covariance: this overrided method can return subclass unstead class:
	 *                  resultSomeSuperclass f_method()
	 *                  resultSomeSubclass   f_overrided_method()
	 *
	 *
	 * }</pre> ПОМНИ СГЕНЕРИТЬ JAVADOC MAC8+fixDocComment И УБРАТЬ ЭТОТ ТЕКСТ
	 
 @throws IllegalArgumentException if argument empty  or null
 
	 */
	public ${NAME} compute(@NotNull final String string )
		{
		
	    notBlank( string);
	    

        #parse("methodcompute.java")
        
        
		return null;
		}
		
		
	 
		
		/*
		
		!! ПОМЕСТИТЬ НИЖЕСЛЕДУЮЩЕЕ В БИЛДЕР
		
		//if you want to modify property inside build()
        #if (${T1} != "")abstract ${T1} item1(); #end
        #if (${T2} != "")abstract ${T2} item2(); #end
        #if (${T3} != "")abstract ${T3} item3(); #end
        #if (${T4} != "")abstract ${T4} item4(); #end
        #if (${T5} != "")abstract ${T5} item5(); #end
        #if (${T6} != "")abstract ${T6} item6(); #end
        #if (${T7} != "")abstract ${T7} item7(); #end
        #if (${T8} != "")abstract ${T8} item8(); #end
        #if (${T9} != "")abstract ${T9} item9(); #end
	    
	    
 		//package access level
 		abstract ${NAME} autoBuild();  
		
  
		public ${NAME} build()
			{
			// Если item2 мутабельный то лучше не копировать(тк копию в гетере здесь сделать не получиться) а присвоить немутабельному типу
			//this.item2(deepCopyOfObject( this.item2() ,  List.class ) );
			
			${NAME} o = autoBuild();
			
			//validate property values here
			#if (${T1} != "") notEmpty(o.item1() ); #end
            #if (${T2} != "") notEmpty(o.item2() ); #end
            #if (${T3} != "") notEmpty(o.item3() ); #end
            #if (${T4} != "") notEmpty(o.item4() ); #end
            #if (${T5} != "") notEmpty(o.item5() ); #end
            #if (${T6} != "") notEmpty(o.item6() ); #end
            #if (${T7} != "") notEmpty(o.item7() ); #end
            #if (${T8} != "") notEmpty(o.item8() ); #end
            #if (${T9} != "") notEmpty(o.item9() ); #end 
			
				
			return o;
			}
		
		//additional builder for collection-property
		#set($cols=(['Immutable' ]) )
        #set( $regex = "([a-zA-Z]+)<([a-zA-Z]+)>")
        #set( $replacement1 = "$1")
        #set( $replacement2 = "$2")
        #set( $part1a = $T1.replaceAll($regex, $replacement1) ) #set( $part1b = $T1.replaceAll($regex, $replacement2) )
        #set( $part2a = $T2.replaceAll($regex, $replacement1) ) #set( $part2b = $T2.replaceAll($regex, $replacement2) )
        #set( $part3a = $T3.replaceAll($regex, $replacement1) ) #set( $part3b = $T3.replaceAll($regex, $replacement2) )
        #set( $part4a = $T4.replaceAll($regex, $replacement1) ) #set( $part4b = $T4.replaceAll($regex, $replacement2) )
        #set( $part5a = $T5.replaceAll($regex, $replacement1) ) #set( $part5b = $T5.replaceAll($regex, $replacement2) )
        #set( $part6a = $T6.replaceAll($regex, $replacement1) ) #set( $part6b = $T6.replaceAll($regex, $replacement2) )
        #set( $part7a = $T7.replaceAll($regex, $replacement1) ) #set( $part7b = $T7.replaceAll($regex, $replacement2) )
        #set( $part8a = $T8.replaceAll($regex, $replacement1) ) #set( $part8b = $T8.replaceAll($regex, $replacement2) )
        #set( $part9a = $T9.replaceAll($regex, $replacement1) ) #set( $part9b = $T9.replaceAll($regex, $replacement2) )

        
        
        #if ($part1a.startsWith("Immutable")))
        
            public abstract Builder item1( final Iterable< ? extends $part1b > item1 );		
		    public abstract Builder item1( final $part1b... item1 );
		    public abstract ${part1a}.Builder< $part1b > item1Builder();
            public Builder addItem1( $part1b value )
                {
                item1Builder().add( value );
                return this;
                }                
        #end
        #if ($part2a.startsWith("Immutable")))
            public abstract Builder item2( final Iterable< ? extends $part2b > item2 );		
		    public abstract Builder item2( final $part2b... item2 );
		    public abstract ${part2a}.Builder< $part2b > item2Builder();
            public Builder addItem2( $part2b value )
                {
                item2Builder().add( value );
                return this;
                }                
        #end
        #if ($part3a.startsWith("Immutable")))
            public abstract Builder item3( final Iterable< ? extends $part3b > item3 );		
		    public abstract Builder item3( final $part3b... item3 );
		    public abstract ${part3a}.Builder< $part3b > item3Builder();
            public Builder addItem3( $part3b value )
                {
                item3Builder().add( value );
                return this;
                }                
        #end
        #if ($part4a.startsWith("Immutable")))
            public abstract Builder item4( final Iterable< ? extends $part4b > item4 );		
		    public abstract Builder item4( final $part4b... item4 );
		    public abstract ${part4a}.Builder< $part4b > item4Builder();
            public Builder addItem4( $part4b value )
                {
                item4Builder().add( value );
                return this;
                }                
        #end
        #if ($part5a.startsWith("Immutable")))
            public abstract Builder item5( final Iterable< ? extends $part5b > item5 );		
		    public abstract Builder item5( final $part5b... item5 );
		    public abstract ${part5a}.Builder< $part5b > item5Builder();
            public Builder addItem5( $part5b value )
                {
                item5Builder().add( value );
                return this;
                }                
        #end
        #if ($part6a.startsWith("Immutable")))
            public abstract Builder item6( final Iterable< ? extends $part6b > item6 );		
		    public abstract Builder item6( final $part6b... item6 );
		    public abstract ${part6a}.Builder< $part6b > item6Builder();
            public Builder addItem6( $part6b value )
                {
                item6Builder().add( value );
                return this;
                }                
        #end
        #if ($part7a.startsWith("Immutable")))
            public abstract Builder item7( final Iterable< ? extends $part7b > item7 );		
		    public abstract Builder item7( final $part7b... item7 );
		    public abstract ${part7a}.Builder< $part7b > item7Builder();
            public Builder addItem7( $part7b value )
                {
                item7Builder().add( value );
                return this;
                }                
        #end
        #if ($part8a.startsWith("Immutable")))
            public abstract Builder item8( final Iterable< ? extends $part8b > item8 );		
		    public abstract Builder item8( final $part8b... item8 );
		    public abstract ${part8a}.Builder< $part8b > item8Builder();
            public Builder addItem8( $part8b value )
                {
                item8Builder().add( value );
                return this;
                }                
        #end
        #if ($part9a.startsWith("Immutable")))
            public abstract Builder item9( final Iterable< ? extends $part9b > item9 );		
		    public abstract Builder item9( final $part9b... item9 );
		    public abstract ${part9a}.Builder< $part9b > item9Builder();
            public Builder addItem9( $part9b value )
                {
                item9Builder().add( value );
                return this;
                }                
        #end



        
        
        
        	
        */			
		
		
		
		
		
		
		
	}
