NAMING

-   название библиотеки может совпадать с иерархией пакетов
        - company-product|technology-feature.DLL
        - company-product|technology.DLL
        - каждое слово с маленькой буквы

СЦЕНАРИИ

-   разбить модуль на пакеты основных сценариев и расширенных
        - высокоуровневое api и низкоуровневое
        - высокоуровневое api обертывает низкоуровневое api в удобные фасады
 
-   НЕ рекомендуется создавать глубокие иерархии пакетов
        - тк их трудно просматривать все время подимаясь вверх по иерархии
        
-   НЕ рекомендуется создавать большое количество пакетов

-   рекомендуется моделировать понятия высокого уровня (например физические объекты) а НЕ задачи системного уровня 
        - например компоненты должны моделировать файлы, каталоги, диски а не потоки, форматтеры, компараторы

1) ОСНОВНЫЕ СЦЕНАРИИ

-   большинство разработчиков использует малый набор общих сценариев
        - поэтому нужно сосредоточить все усилия на этих нескольких общих сценариях

-   те основные сценарии это часто используемые области функциональных возможностей

-   наличие упрощенных операций высокого уровня крайне важно для тех разработчиков, 
    который не хотят изучать весь спектр функциональных возможностей 
    а должны только решать свой часто очень простые задачи
          
-   пакеты основных сценариев должны быть выше в иерархии чем расширенных
        - те типы расширенных сценариев должны быть помещены в ПОДпакеты/ПОДклассы основных сценариев

-   самые простые и короткие названия использовать для типов из общих сценариев
        - чтобы пользователи угадали с первого раза что делает тип, даже если он противоречит иерархии наследования
        - лучшие и наиболее легко распознаваемые названия для наиболее часто используемых типов (даже если название лучше соответствует другому редко используемому типу)
        - листья должны быть более красивым названием чем корень тк большинство пользователей используют только листья а не корни
        - это увеличивает "видимость" и находимость юзером типов из основных сценариев

-   общий api должен включать в себя 5-10 основных сценариев

-   в самых основных сценариях должны создаваться объекты только одного типа

-   следует оптимизировать производительность основного api

-   можно заимствовать названия и общую часть сценариев из других общеизвестных api, фреймворки и библиотеки
        - тогда пользователь уже будет знать как как обращаться с новым api по аналогии с уже известным ему другим api
        - копировать только общие части api, уникальные должны быть своими

-   общий api должен быть простой
        - следует сделать так чтобы простые сценарии api можно было использовать и БЕЗ ДОКУМЕНТАЦИИ
        - разработчик должен смочь начать НЕМЕДЛЕННО применять api
        - самоочевидный api не требует знания взаимодействия множества объектов внутри 
        - самое худшее - дизайн api, который выглядит простым, но как только разработчики начинают использовать его, 
         они обнаруживают что это не так (иногда обнаруживают с большим трудом и часами копаний)

-   следует удостовериться что компоненты поддерживают паттерн create-set-call
        - юзеры должны быть в состоянии закодить большинство сценариев через этот паттерн   

-   не должно быть обширной инициализации(и конфигов) для основных сценариев 
        тк они поднимают порог входа и требуют знания подводных взаимосвязей
           

2) РАСШИРЕННЫЕ СЦЕНАРИИ

-   редко используемые типы должны быть помещены в отдельные подпакеты        
        
-   низкоуровневые api также полностью должен дублировать функционал высокоуровневого api чтобы разработчик мог выбирать

-   сложные вещи должны быть возможными с помощью расширенного api
        - хотя бы если не легкими ,как например в основных сценариях, то хотя бы возможными
        - для того чтобы понять расширенный api юзеру понадобится документация и знаниние особенностей внутренней реализации низкоуровневого api



    


CONVENTIONS

-   наличие классов открытых для настройки является одним из основных отличий инфраструктуры от библиотеки
    
-   различные фреймворки/библиотеки/модули должны быть сочетаемы между собой

-   библиотеки должны быть "скучными" (только основной функционал)

-   нельзя требовать чтобы юзеры делали что-либо помимо кода
        - например конфигурировали компоненты в файле конфигурации, генерировали файлы ресурсов
        - пример антипаттерна: IoC конфигурируемый в файле конфигурации Spring Framework или Spring boot

-   разбить функции на отдельные типы так чтобы свойства/методы не перекрывались

    