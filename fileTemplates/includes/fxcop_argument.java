NAMING

-   имена аргументов начинаются с маленькой буквы, верблюжий стиль

-   в двубуквенных акронимах обе первых буквы маленькие
        - например ioStream

-   тк параметры-методов отображаются в документации и автоподстановках то для них тоже должны действовать правила именования

-   названия параметров должны быть настолько описательными, чтобы используя с их типами,  можно было определить их значение в большинстве сценариев

-   если нет иного смысла то в крайнем случае называть параметры:
        - left, right
        - value
        
-   НЕ использовать числовые индексы
        - например: param1, param2

-   ?должно быть основано на значении а не на типе
        - тк IDE само покажет тип
-   ?название параметра не должно совпадать с названием свойства/метода/класса
        - тк вероятно, что это название не является достаточно описательным, чтобы быть полезным
-   ?название пареметра должно совпадать с названием типа
         - это экономит значимые имена


CONVENTIONS

1)   тип параметра - наивысший возможный тип в иерархии
        - тогда расширится набор возможных подтипов объектов, которые может принять данный параметр
        - например интерфейс Collection<> а не конкретный тип коллекции (в случае если нужно просто перечислить элементы)

2)   если требуется вызывать определенные методы объекта параметра то нужно наоборот ограничить "наивысший возможный тип в иерархии"

-    нельзя резервировать параметры "на будущее"
        - лучше в будущем сделать перегруженную версию метода с новым параметром

-   термины параметр и аргумент означают одно и то же


ПАТТЕРН NEW-SET-CALL В МУТАБЕЛЬНЫХ КЛАССАХ    
    
1)   методы не имеют параметров, которые должны быть постоянными во всех вызовах метода в основных сценариях
        - тк такие постоянниые аргументы должны задаваться свойствами
        - те только такие параметры которые нужны для каждого вызова и не остаются постоянными
        
2)   следует добавить параметр к методу если я хочу сделать акцент на параметре
        - те сделать очевидной связь между параметром и методом
        - например timeout задавать метода, несмотря на то что он одинаковый при каждом вызове
    
-   следует проверить консистентность объекта, так как могут быть пролемы из за 
        - свойства могут быть установлены произвольно и независимо что в итоге приводит к противоречивому состоянию объекта
        - конструктор по умолчанию позволяет пользователям создать недо-инициализированный экземпляр
-   при неконсистентности объекта следует вызывать исключения IllegalStateException
        - сообщение исключения должно ясно объяснять, какие свойства должны быть изменены, чтобы получить объект в допустимом состояний
        - исключения должны быть вызваны тогда когда операция выполняется а не когда компонент инициализируется

ПРОВЕРКА АРГУМЕНТОВ

1)  следует разрешить передачу null указателя в качестве параметра метода
        - чтобы избежать проверку на null до вызова функции и перенести ее внутрь вызова функции 
        и в случае нуля внутри метода проставить значение про умолчанию
        
2)  а если null не разрешен то вызывать ArgumentNullException

-   необходимо обязательно проверять все параметры public, protected методов, переданные на вход методу юзером

-   необходимо осуществлять проверки параметров столь тщательно насколько это возможно
         - тк это обеспечит лучшее сообщение об ошибке
        
-   при ошибке в параметре следует вызывать ArgumentException    

-   необходимо помнить что мутабельные объекты могут измениться уже после проверки
        - если я не хочу распространять побочный эффект, то я могу сделать КОПИЮ объекта(!не копию ссылки), проверить ЕЕ и передать ЕЕ дальше

1)  сама проверка не обязательно должна производиться непосредственно в этом паблик методе, она может производится и на более низком уровне в подметодах и тп  

2)  проверки аргументов лучше поместить вверх по иерархии ближе к общему api и дальше от расширенных низкоуровневых сценариев
        - тк низкоуровневые функции вызываются чаще то и стоят они дороже       


COMMON TYPES vs SPECIAL/USER TYPES

-   рекомендуется использовать специфические типы данных (например URL), а не общие (например String) 
        - например, рекомендуется URL даже если вместо него можно использовать String
        
-   следует везде использовать специфические типы для:
        1) свойства класса
        2) возвращаемые значения методов
        3) аргументы методов

-   для своих методов принимающих на вход СПЕЦИФИЧЕСКИЙ ТИП(например url) 
    для удобства рекомендуется обеспечить для глупых юзеров перегруженные версии методов, принимающих ОБЩИЙ ТИП(например строку) 
    но вызывающих версию с специфическим типом (те url)
        - если достаточно часто от пользователя принимается строка то вы должны добавить удобную перегрузку для приема строки
        - такие методы предназначаются в качестве помошников для часто встречающихся сценариев
        - будте избирательны и предоставляйте такие помошники только для часто используемых вариантов
        - нельзя все методы с аргументом типа url слепо автоматически перегружать версиями со строкми тк предпочтительней api на основе url
        - нельзя чтобы была только версия метода со String без метода с URL
        
    
    
    
    
    
    