NAMING

-   добавить к имени суффикс Exception

-   отказ происходит когда метод не может сделать то для чего был спроектирован
        - например, если метод не делает то что предполагает его название, это нужно считать отказом на уровне метода
        - ?таким образом исключение можно назвать CanNotMethodnameException


CONVENTIONS

-   необходимо задокументировать в джавадоках все исключения вызываемые из за нарушения контракта метода

-   такие исключения внешне не должны меняться тк они уже являются частью контракта в джавадоках

-   когда юзер использует основное api, то он не должен получить исключения расширенного api
        - юзер основного api должен получать только исключения основного api
        - для этого низкоуровневые исключения можно оборачивать в высокоуровневые
        
-   нельзя использовать исключения для обычного управления потоком
        - те подразумевать что ошибка будет вызываться часто или систематически
        - исключения используются ТОЛЬКО для сообщений об ошибках, проблемах, отказах, нештатных ситуациях

-   следует конструктору исключения передавать дополнительную информацию о контексте
        - те нельзя вызывать у исключения конструктор без параметров

-   рекомендуется делать исключение Serializable
        - исключения по умолчанию Serializable тк наследуются от Throwable
        - чтобы его можно было делать удаленную отладку и пробрасывать его через удаленное взаимодействие

-   рекомендуется в свой класс иксепшена добавлять гетеры/сетеры для хранения дополнительной информации об ошибке и контексте ошибки

-   иксепшен обязательно должен быть public 
        - иначе его невозможно будет перехватить
        - но можно будет перехватить парентовое исключение

-   рекомендуется выносить вызов иксепшена в отдельный метод
        - чтобы сократить код, если иксепшен часто вызывается
        - либо вынести  throw new exception
        - либо вынести только new exception, это лучше для unsupportedOperationException тк не придется писать return

-   нельзя ЯВНО вызывать исключения из finally блоков
        - но неявно можно

-   нельзя вызывать иксепшен внутри класса исключения

-   исключение должно содержать 4 стандартных конструктора
        - public Exception() 
        - public Exception(String message) 
        - public Exception(String message, Throwable cause) 
        - public Exception(Throwable cause) 


СОДЕРЖАНИЕ СООБЩЕНИЯ ОБ ОШИБКЕ

1)  сам тип исключения является самой важной информацией 
        - на основе типа исключения программа решает что с ним делать

2)  исключение должно ясно описывать что нужно сделать чтобы устранить проблему
        - текст сообщения предназначается прежде всего для разработчика
        - конечные пользователи не должны видеть эти сообщения
        - сообщения об ошибках должны помогать разработчикам устранять ошибки в коде
        - обязательно нужно сообщить о неправильном способе использования api
        
3)  сообщение о причине отказа, объясняющее что пошло не так
   
4)  исключение само по себе это документация
        - исключение это лучший вид документации тк многие разработчики предпочитают кодировать методом проб и ошибок а не чтением мануалов
        - рекомендуется вызывать самое специфическое исключение которое имеет смысл те наиболее глубокое/подробное в иерархии наследования

-   нужно локализовать сообщение на различные языки

-   нельзя раскрывать важную информацию безопасности
        - если у конечного пользователя нет соответствующих полномочий
        - следует сделать отдельные методы(которые может вызвать только доверненный код) для возврата такой информации
        - следует в toString иксепшена ввести код запрашивающий права на выввод секретной информации

-   сообщение должно быть грамматически и синтаксически правильно
        - каждое предложение текста должно заканчиваться точкой.
        - нельзя использовать вопросительные и восклицательные знаки

-   убедитесь что терминология используемая в сообщениях об ошибках имеет смысл в том контексте в котором она употребляется
        - например низкоуровневая терминология имеет смысл только для тех кто работает на нижнем уровне
     
     
        
ТИПЫ ИСКЛЮЧЕНИЙ
 
1) ошибки программирования, ошибка неправильного использования API 
        - возникает в результате неправильно написанной программы
        - такие ошибки не обрабатывают НАДО перепрограммировать код
        - разработчик должен гарантировать что такая ошибка никогда не произойдет во время выполнения
        - нужно остановить прогу и подробно сообщить юзеру
        - для вызова исключения, можно использовать существующий подтип от RuntimeException:
        . UnsupportedOperationException вызывается например, при попытке использовать методы записи в readonly коллекциях    
            	- например попытка использовать объект до правильной его инициализации
	            - например запись в файловый поток, который был открыт для чтения
	            - напрмиер метод пытается обратится к несуществующему ресурсу
        . NullPointerException          Objects.requireNonNull()
        . IndexOutOfBoundsException     Objects.checkIndex()
        . IllegalStateException         вызываем напрмиер, когда значения свойств объекта противоречат друг другу и мтеод невозможно вызвать
        . IllegalArgumentException      вызываем например, когда юзер передает неправильное значение аргумента в метод
        . ConcurrentModificationException если объект в одном потоке, обнаруживает что его меняют/изменили из параллельного потока     
        
2) ошибка выполнения  
        - такая ошибка может быть обработана программно, например компенсирующей логикой
        - для вызова исключения, рекомендуется создать свое исключение наследуемое от RuntimeException
        - можно использовать суффикс ..ApplicationException
    
3) системные отказы   
        - при системном отказе лучше просто завершить программу 
            

СТРАТЕГИИ РАБОТЫ С ИСКЛЮЧЕНИЕМ В МЕТОДЕ
по умолчанию подразумеваются unchecked/непроверяемые исключения

1)  throw concrete UNchecked exception strategy
        - просто генерируем в процедуре иксепшен, иксепшен должен быть необщим
        - стратегия прерывания
        - иксепшен просто пробрасывается автоматически вверх
        - таким образом это поможет централизовать отлов ошибок на более верхнем уровне
   
2)  catch concrete exception / resolve exception strategy
        - стратегия компенсации и возобновления работы 
        - те ошибка разрешается прямо здесь
        - ловим только конкретные иксепшены, остальные будут пробрасываться вверх
        - перехватить исключение в точке отказа
        - перехватывать исключение стоит только когда вы понимаете что оно было вызвано в данном контексте и вы знаете как изящно исправить ситуацию
        - перехватывать исключение рекомендуется на более верхнем уровне тк слишком частые исключения на нижнем будут влиять на производительность

3)  rethrow exception strategy: checked->unchecked
        - обязательное/проверяемое/checked исключение оборачивается в unchecked/непроверяемые исключение
        - иксепшен просто пробрасывается автоматически вверх
        - нужно при повторном вызове исключения, прицепить к нему исходное чтобы непотерялся стек вызовов тк если просто повторно вызвать исключение то оно заместит первоначальное
         
4)  обработчик необработанных ситуаций, завершает работу программы
        - рекомендуется завершать процесс когда код сталкивается с ситуацией в которой дальнейшее выполнение опасно для целостности данных
        - обрабатывайте только те исключения на которые приложение может ответить разумно иначе завершайте прогу
        - следует юзеру показать стандартное сообщение: "Microsoft Word столкнулся с проблемой и должен закрыться. Мы приносим извинения за причиненные неудобства."
        - обработчик необработанных ситуаций используется чтобы восстановить файл и запустить приложение повторно
        - можно также послать письмом сведения об ошибке, позволяющее улучшить продукт

АЛЬТЕРНАТИВНЫЕ СТРАТЕГИИ

1)  return optional strategy
        - возврат в методе опциональтного значения, которое в случае ошибки будет пустым
        - но вы НЕ получаете продолжения работы операторов и методов на пустых значениях
        - нельзя делать аргумент optional для того чтобы передать параметр по умолчанию, вместо этого лучше сделать две перезагружаемых функции 
        - нельзя использовать Optional того чтобы представить общее значение с тремя состояниями, вместо этого лучше использовать enum

2)  return default value strategy
        - в случае ошибки вернем объект пустышку 
        - таким образом мы получим продолжение работы программы на пустых значениях

3)  паттерн tester-doer
        - например, метод add (для добавления элемента в коллекцию) вызовет исключение, если коллекция предназначена только для чтения
          это может быть проблемой производительности в сценариях где метод будет часто терпеть неудачу
          поэтому, прежде чем попытаться добавить значение, следует проверить коллекцию тестер-методом isReadOnly
        - паттерн улучшит производительность если ТЕСТ стоит намного дешевле чем ДЕЙСТВИЕ с вызовом иксепшена
        - этот паттерн может внести условия гонки в многопоточном вызове метода в случае если класс изначально проектировался с учетом многопоточности(что скорее всего не так)
        - tester -метод используемый для проверки предусловий другого метода, и возвращающий bool (вместо исключения)
        - doer  -метод который фактически делает работу

4)  паттерн try-parse
        - данный паттерн рекомендуется только если нужно улучшить производительность в низкоуровневом api
        - если у нас есть метод (например Parse) который может вызывать исключение 
          то мы можем сделать альтернативную версию метода (назовем его TryParse) без исключения
        - он будет возвращать true при успехе а также результат в out переменной  или в кортеже (true,result)  
        - Parse - это на самом деле любой метод для которого делаем альтернативный метод
        - TryParse - это альтернативный метод не вызывающий исключения и возвращающий (true|false,result|null)  

НЕ РЕКОМЕНДУЕМЫЕ СТРАТЕГИИ РАБОТЫ С ИСКЛЮЧЕНИЕМ В МЕТОДЕ

1)  catch all exceptions strategy: catch(Exception e),  catch(RuntimeException e)
        - категорически нельзя "глотать" ошибки перехватывая неопределенные общие исключения
        - в таком случае вы вообще не можете предсказать в каком состоянии находится программная модель. 
        - вы рискуете что что польза продолжения работы проги превысит риск обработки недостоверных данных
        - это разрешается только для передачи этого исключения другому потоку те оно в этом случае на самом деле не глотается

2)  throw Exception/RuntimeException strategy
        - не следует вызывать общие исключения
        - тк эти исключения являются слишком общими, чтобы предоставить полезную информацию

3)  throw concrete checked exception / throws strategy
        - генерируем в процедуре проверяемый/checked иксепшен, должен быть не общим
        - не рекомендуется генерировать проверяемые исключения
        - не рекомендуется делать методы throws

4)  rethrow exception strategy: checked->checked 
        - не рекомендуется тк при новом исключении вы сообщаете уже о новом отказе, вместо того отказа который произошел фактически  
        - но иногда выгодно обернуть исключение нижнего уровня в исключение которое значимо для пользователей более высокого уровня
        - такое обертывание должно быть редким
        - у этого обертывания, вероятно, будет негативное влияние на возможности отладки
        - практика catch c обертыванием нежелательна и является только еще одной формой проглатывания ошибок

5)  return null strategy
        - не рекомендуется использовать тк в при попытке использования вызовется исключение
        - приводит к частым проверкам на null

6)  return error
        - не рекомендуется возвращать ошибку или код ошибки в return
        - наличие двух альтернативных механизмов сообщения об ошибках запутывает и ведет к несогласованному применению API
        - исключения в отличие от return невозможно проигнорировать что повышает надежность и устойчивость кода
        - но вы все равно можете в return возвращать информацию о состоянии в случае успешной операции тк юзер может ожидать этого (например число вставленных записей и тп)
        - для исключений созданы специальные инструменты: отладчики, профилировщики
        - исключения не связаны с сигнатурой метода, что дает возможность проектировать возвращаемое значение независимо


