NAMING

-   добавить к имени функционального интерфейса суффикс 
        - EventHandler
        - Callback

-   добавить к имени метода функционального интерфейса raise
        - не использовать слова fire, trigger


CONVENTIONS

-   рекомендуется использовать стандартный интерфейс EventHandler<Т>

-   параметры метода функционального интерфейса для обработчика события:
        - Object sender - для передачи объекта от кого пришло событие
        - EventArgs e   - для передачи аргументов события
        - void          - для возвращаемого результата
    
-   в классе EventArgs рекомендуется сделать параметр события Cancel для отмены события изнутри хендлера
        
-   рекомендуется уведомлять об изменениях свойств только в высокоуровневых api общих сценариев
        - иначе такие события будут приходить слишком часто если вынести их на более низкий уровень
    
-   события уведомляющие об изменении свойств: рекомендуется уведомлять только когда свойства меняются извне

-   при вызове события юзеру категорически запрещается 
        1) указывать нулевого сендера при отправке события тк подписчики могут его использовать и ожидают что он будет ненулевым    
        2) указывать нулевой параметр события, лучше передавать EventArgs.Empty

-    у лямбд могут быть проблемы с блокировками тк юзерский код лямбды неизвестен

  
    
РАСШИРЯЕМОСТЬ

-   нельзя требовать чтобы юзеры: наследовали классы или имплементировали интерфейсы лучше использовать вместо этого лямбды  
        - лямбды можно сравнить с расширяемостью через abstract методы
        - лямбды проще для юзеров тк не требуют знания ООП наследования и паттерна шаблонного метода
        - лямбды могут обеспечить расширяемость runtime , а abstract методы имплементируются только во время компиляции
        - лямбды более медленно работают (и занимают в памяти больше метста) чем заранее скомпилированные переопределенные методы

-   лямбды обеспечивают расширяемость за счет возможности вызова пользовательского кода из инфраструктуры
        - лямбды обычно передают в параметре метода
        
-   вместо EventArgs для передачи параметра события рекомендуется пользовательский подкласс
        - тогда потом его всегда можно будет расширить доп свойствами

АРГУМЕНТ МЕТОДА - ЛЯМБДА
    
-   рекомендуется использовать стандартные типы лямбд, вместо создания пользовательских лямбда-интерфейсов
        - interface Function<T, R>      R apply(T t);
        - interface UnaryOperator<T>    T apply(T t);
        - interface BiFunction<T, U, R> R apply(T t, U u);
        - interface BinaryOperator<T>   T apply(T t, T u);
        - interface Predicate<T>        boolean test(T t);
        - interface Consumer<T>         void accept(T t);
        - interface Supplier<T>         T get();

   