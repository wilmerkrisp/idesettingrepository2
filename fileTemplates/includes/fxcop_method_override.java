NAMING

-   следует одинаковые параметры в исходном и переопределенном методах называть одинаково
        
-   название абстракт метода = название public метода + суффикс Core
        - нельзя использовать устаревший суффикс Impl

CONVENTIONS


ФИНАЛИЗАЦИЯ МЕТОДОВ

-   рекомендуется финализировать юзерские методы переопределенные от abstract
        - особенно если я не планирую здесь думать о расширяемости дальше 

-   как только я финализирую метод, я могу избежать побочных эффектов связанных с наследованием моего юзерского класса

-   можно все public мтеоды сделать final, а шаблонные методы сделать abstract
        - как алтернатива паттерну "вызов privete версий методов из public"


РАСШИРЯЕМОСТЬ ABSTRACT МЕТОДАМИ

-   abstract метод обеспечивает принудительную расширяемость   

-   если сделать метод abstract то юзер точно должен его отнаследовать

-   следует тщательно задокументировать 
        - тк юзеру нужно подробно объяснить как их нужно заместить, 
        объяснить бзеру что такое паттерн шаблонный метод и тп

-   следует тщательно запроектировать: 
        - те должен быть ясный сценарий, требующий расширяемости, 
        - те вы уже придумали как юзер должен их использовать

-   нельзя делать члены abstract, если нет серьезного основания и вы учитываете стоимость проектирования, тестирования, поддержки abstract методов

-   изменение abstract методов в будущем чревато большим риском нарушения совместимости

-   следует делать abstract методы также и protected


РАСШИРЯЕМОСТЬ PROTECTED МЕТОДАМИ        

-   protected метод обеспечивают расширяемость не усложняя основной public интерфейс

-   protected методы надо проектировать так же тщательно как и public 
        - те внутри надо обеспечивать такой же уровень проверок и документирования
        
-   не рекомендуется делать public методы абстрактными 
        - тк фишка паттерна как раз в том чтобы разнести public и abstract методы        
        
РАСШИРЯЕМОСТЬ ABSTRACT PROTECTED МЕТОДАМИ 

-   abstract методы создаются protected только для расширения НО не для прямого использования юзером

ПАТТЕРН ШАБЛОННЫЙ МЕТОД

-   следует делать ABSTRACT только самую длинную перегрузку
        - все более короткие версии будут использовать эту длинную версию
        
-   шаблонный метод следут делать PROTECTED abstract чтобы расширяемость была управляемой
        - те его нельзя было вызвать напрямую извне но нужно было переопределить
                
-   в коротких неперезагружаемых версиях будет реализована вся скучная логика проверки входных параметров  
        - такие методы можно сделать public final

-   рекомендуется ограничить расширяемость только тем что АБСОЛЮТНО НЕОБХОДИМО с помощью шаблона template method  

-   следует использовать этот паттерн для достижения управляемой расширяемости тк юзер должен переопределить только некоторые методы

-   нельзя делать перегрузку abstract метода
        - тк будет уже два абстрактных метода и их оба придется наследовать одновременно, 
        а пользователь может этого не знать и переопределить только один метод

-   рекомендуется проверять параметры в public методе чтобы не проверять их каждый раз в abstract методах


ПАТТЕРН КАСКАД ФАСАДОВ

-   паттерн используется для централизации логики в одном месте

-   можно использовать лесенку перезагрузок: метод использует вызов следующего перегруженного с +1 параметром
        - для централизации логики в одном месте

-   самый последний метод в лесенке может быть как раз protected abstract шаблонным методом
        - с самым большим количеством параметров

ПАТТЕРН ПРИВАТНЫХ/FINAL МЕТОДОВ ВЫЗЫВАЮЩИХСЯ ИЗ ПЕРЕОПРЕДЕЛЯЕМЫХ МЕТОДОВ

см блох




ПЕРЕОПРЕДЕЛЕНИЕ МЕТОДА EQUALS и HASHCODE

1)   СЛЕДУЕТ обязательно переопределлять данный метод для НЕМУТАБЕЛЬНЫХ классов-значений
        - следует сравнить все свойства по значению
        - не рекомендуется использовать если реализация получается медленной

2)   НЕЛЬЗЯ переопределять данный метод для МУТАБЕЛЬНЫХ классов основываясь на равенстве всех свойств
        - тк как только одно из свойств изменится то равенство сразу потеряется
        - также объект потеряется сразу в хэш таблицах тк хэш объекта изменится
        - обычно по-умолчанию equals смотрит на равенство ссылок и многие юзеры удивятся, когда поведение по умолчанию изменено на равенство значений
        
-   для мутабельных классов (например DDD агрегатов) следует переопределять данный метод отталкиваясь от равенства свойства выбранного для определения идентичности
        - рекомендуется убедиться что hashcode возвращает точно то же самое значение независимо от любых изменений сделанных с объектом

-   следует перезагружать и переопределять equals
        - например будет два метода equals(MyClass p) и equals(object p)

-   каждый раз когда реализую IComparable следует переопределять equals
        - но наоборот делать необязательно: те когда делаю equals не всегда нужен comparable 

-   equals и hashCode следует переопределять одновременно 
        - эти оба контракта взаимозависимы и они оба используются главным образом для поиска
        - это гарантирует что два объекта которые рассматриваются как равные, имеют один и тот же хэш-код
        - если объекты НЕ равны то они ТОЖЕ могут иметь один и тот же хэш код

-   рекомендуется убедиться что если equals для каких нибудь двух объектов возвращает true, 
    то hashcode возвращает одно и то же значение для этих объектов

-   следует гарантировать что hashcode генерирует случайное распределение чисел для всех объектов данного типа
        - тк это минимизирует коллизии (совпадения ключей) в хэш-таблице, тк коллизии снижают производительность
    
-   нельзя вызывать исключения из equals и hashCode
        - из equals лучше возвратить false чем вызвать исключение

-   кстати на неизменяемых ссылочных типах тяжело заметить различие между равенством ссылок и равенством значений
 
ПЕРЕОПРЕДЕЛЕНИЕ МЕТОДА CLONE (ИНТЕРФЕЙС CLONEABLE)

-   t-f: не рекомендуется переопределять и вообще использовать данный метод
        - вместо него нужно использовать глубоко-копирующий конструктор или фабрику

-   у этого метода и интерфейса совершенно нетипичный способ использования
        - если поставить классу интерфейс-маркер Cloneable то метод Object.clone станет public
        - при условии что в каждом классе в методе Clone нужно вызывать super.clone что в итоге приведет к вызову Object.clone (это непринудительное сцепление конструкторов)
        - получается что объект не создается явно с использованием конструктора, а создается внутри Object.clone
        - для мутабельного объекта с мутабельными свойствами следует сделать рекурсивный вызов метода clone для всех свойств
        
-   следует просто переопределить метод clone но не писать implements Cloneable
        - тк по этому маркерному интерфейсу юзеры не поймут глубокая это копия или поверхностная
                    
-   следует явно написать в JavaDoc что это глубокая или поверхностная копия    
    
-   типы копирования
        1)  глубокое копирование, копирует объект и рекурсивно те все объекты в графе
        2)  поверхностное копирование, копирует только часть графа    

ПЕРЕОПРЕДЕЛЕНИЕ МЕТОДА TOSTRING

-   предназначен только для целей отладки
        - каждый разработчик может менять данный метод как хочет, поэтому этот метод нестабилен

-   не предназначен для вывода конечному пользователю в UI
        - для этого нужно делать свои отдельные методы

-   следует переопределять данный метод тк заданная по умолчанию реализация не очень полезна    
    
-   надо строку возвращаемую из toString делать максимально короткой
        - не больше чем длина одного экрана помещаемая в дебагере (80 символов)

-   рекомендуется возвращать уникальную строку, связанную с данным экземпляром класса
        - те хэш-код или адрес в памяти 

-   надо выводить более понятные имена свойств, в случае если их настоящие названия нечитаемы

-   cледует выводить локализованную строку, зависящую от региона
        - в случае форматирования денег и дат
        - надо отформатировать строку в соответствии с текущими региональными настройками Locale.getDefault()
        
-   нельзя возвращать пустую строку или null        

-   нельзя вызывать исключения внутри метода  

-   нельзя чтобы у toString были побочные эффекты
        - тк это одна из причин по которой ее вызывают отладчики иначе это может сильно затруднить отладку 
 
-   рекомендуется выводить значение, которое можно разобрать синтаксическим анализатором для данного типа
        - на типе сделать комплиментарный метод MyType.parse(obj.toString()) для разбора строки обратно в объект
 
-   следует учесть секьюрити и безопасность того что информация может попасть не в те руки тк данное сообщение может иногда попасть в UI
        - внутри метода запрашивать разрешения на вывод секретной информации, и если разрешения нет то вернуть только несекретную информацию
    
    
    
    
    
    