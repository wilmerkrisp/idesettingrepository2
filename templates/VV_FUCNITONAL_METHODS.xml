<templateSet group="VV_FUCNITONAL_METHODS">
  <template name="fx method try" value="// = Success(result) or Failure(exception) &#10;public Try&lt;Integer&gt; divide(Integer dividend, Integer divisor) &#10;&#9;{&#10;&#9;return Try.of(() -&gt; dividend / divisor);&#10;&#9;// todo postcondition check of output result&#10;&#9;}" description="VAVR supplier-&gt;try" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="fx method option" value="public Option&lt;String&gt; $method$( final String string )&#10;&#9;{&#10;&#9;return Option( string ).filter( StringUtils::isNotBlank )&#10;&#9;                       .onEmpty( logAtWarningRunnable( &quot;$class$.$method$(empty argument)&quot; ) )&#10;&#9;                       .map( logAtDebugUnaryOperator( &quot;$class$.$method$&quot; ) )&#10;&#9;                       .flatMap( this::$method$_ );&#10;&#9;// todo postcondition check of output result&#10;&#9;}&#10;&#10;&#10;&#10;public Option&lt;String&gt; $method$_( final String string )&#10;&#9;{&#10;&#9;return Option( &quot;otvet+&quot; + string );&#10;&#9;}" description="VAVR supplier-&gt;try" toReformat="false" toShortenFQNames="true">
    <variable name="class" expression="className()" defaultValue="" alwaysStopAt="false" />
    <variable name="method" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="fx option README" value="default &lt;R&gt; Option&lt;R&gt;&#10;         collect(PartialFunction&lt;? super T,? extends R&gt; partialFunction)&#10;&#9;&#9;Collects value that is in the domain of the given partialFunction by mapping the value to type R.&#10;&#10;boolean&#10;&#9;equals(Object o)&#10;&#9;&#9;Clarifies that values have a proper equals() method implemented.&#10;&#10;default Option&lt;T&gt;&#10;&#9;filter(Predicate&lt;? super T&gt; predicate)&#10;&#9;&#9;Returns Some(value) if this is a Some and the value satisfies the given predicate.&#10;&#10;default &lt;U&gt; Option&lt;U&gt;&#10;         flatMap(Function&lt;? super T,? extends Option&lt;? extends U&gt;&gt; mapper)&#10;&#9;&#9;Maps the value to a new Option if this is a Some, otherwise returns None.&#10;&#10;default &lt;U&gt; U&#10;&#9;fold(Supplier&lt;? extends U&gt; ifNone, Function&lt;? super T,? extends U&gt; f)&#10;&#9;&#9;Folds either the None or the Some side of the Option value.&#10;&#10;T&#10;&#9;get()&#10;&#9;&#9;Gets the value if this is a Some or throws if this is a None.&#10;&#10;default T&#10;&#9;getOrElse(Supplier&lt;? extends T&gt; supplier)&#10;&#9;&#9;Returns the value if this is a Some, otherwise the other value is returned, if this is a None.&#10;&#10;default T&#10;&#9;getOrElse(T other)&#10;&#9;&#9;Returns the value if this is a Some or the other value if this is a None.&#10;&#10;default &lt;X extends Throwable&gt; T&#10;&#9;getOrElseThrow(Supplier&lt;X&gt; exceptionSupplier)&#10;&#9;&#9;Returns the value if this is a Some, otherwise throws an exception.&#10;&#10;int&#10;&#9;hashCode()&#10;&#9;&#9;Clarifies that values have a proper hashCode() method implemented.&#10;&#10;default boolean&#10;&#9;isAsync()&#10;&#9;&#9;An Option's value is computed synchronously.&#10;&#10;default boolean&#10;&#9;isDefined()&#10;&#9;&#9;Returns true, if this is Some, otherwise false, if this is None.&#10;&#10;boolean&#10;&#9;isEmpty()&#10;&#9;&#9;Returns true, if this is None, otherwise false, if this is Some.&#10;&#10;default boolean&#10;&#9;isLazy()&#10;&#9;&#9;An Option's value is computed eagerly.&#10;&#10;default boolean&#10;&#9;isSingleValued()&#10;&#9;&#9;An Option is single-valued.&#10;&#10;default Iterator&lt;T&gt;&#10;&#9;iterator()&#10;&#9;&#9;Returns a rich io.vavr.collection.Iterator.&#10;&#10;default &lt;U&gt; Option&lt;U&gt;&#10;         map(Function&lt;? super T,? extends U&gt; mapper)&#10;&#9;&#9;Maps the value and wraps it in a new Some if this is a Some, returns None.&#10;&#10;static &lt;T&gt; Option&lt;T&gt;&#10;        narrow(Option&lt;? extends T&gt; option)&#10;&#9;&#9;Narrows a widened Option&lt;? extends T&gt; to Option&lt;T&gt; by performing a type-safe cast.&#10;&#10;static &lt;T&gt; Option&lt;T&gt;&#10;        none()&#10;&#9;&#9;Returns the single instance of None&#10;&#10;static &lt;T&gt; Option&lt;T&gt;&#10;        of(T value)&#10;&#9;&#9;Creates a new Option of a given value.&#10;&#10;static &lt;T&gt; Option&lt;T&gt;&#10;        ofOptional(Optional&lt;? extends T&gt; optional)&#10;&#9;&#9;Wraps a Java Optional to a new Option&#10;&#10;default Option&lt;T&gt;&#10;&#9;onEmpty(Runnable action)&#10;&#9;&#9;Runs a Java Runnable passed as parameter if this Option is empty.&#10;&#10;default Option&lt;T&gt;&#10;&#9;orElse(Option&lt;? extends T&gt; other)&#10;&#9;&#9;Returns this Option if it is nonempty, otherwise return the alternative.&#10;&#10;default Option&lt;T&gt;&#10;&#9;orElse(Supplier&lt;? extends Option&lt;? extends T&gt;&gt; supplier)&#10;&#9;&#9;Returns this Option if it is nonempty, otherwise return the result of evaluating supplier.&#10;&#10;default Option&lt;T&gt;&#10;&#9;peek(Consumer&lt;? super T&gt; action)&#10;&#9;&#9;Applies an action to this value, if this option is defined, otherwise does nothing.&#10;&#10;static &lt;T&gt; Option&lt;Seq&lt;T&gt;&gt; &#10;         sequence(Iterable&lt;? extends Option&lt;? extends T&gt;&gt; values)&#10;&#9;&#9;Reduces many Options into a single Option by transforming an  Iterable&lt;Option&lt;? extends T&gt;&gt; into a Option&lt;Seq&lt;T&gt;&gt;.&#10;&#10;static &lt;T&gt; Option&lt;T&gt;&#10;        some(T value)&#10;&#9;&#9;Creates a new Some of a given value.&#10;&#10;String&#10;&#9;toString()&#10;&#9;&#9;Clarifies that values have a proper toString() method implemented.&#10;&#10;default &lt;U&gt; U&#10;&#9;transform(Function&lt;? super Option&lt;T&gt;,? extends U&gt; f)&#10;&#9;&#9;Transforms this Option.&#10;&#10;static &lt;T,U&gt; Option&lt;Seq&lt;U&gt;&gt;&#10;        traverse(Iterable&lt;? extends T&gt; values, Function&lt;? super T,? extends Option&lt;? extends U&gt;&gt; mapper)&#10;&#9;&#9;Maps the values of an iterable to a sequence of mapped values into a single Option by transforming an Iterable&lt;? extends T&gt; into a Option&lt;Seq&lt;U&gt;&gt;.&#10;&#10;static &lt;T&gt; Option&lt;T&gt;&#10;        when(boolean condition, Supplier&lt;? extends T&gt; supplier)&#10;&#9;&#9;Creates Some of suppliers value if condition is true, or None in other case&#10;&#10;static &lt;T&gt; Option&lt;T&gt;&#10;        when(boolean condition, T value)&#10;&#9;&#9;Creates Some of value if condition is true, or None in other case" description="VAVR supplier-&gt;try" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="fx method option+try" value="public Option&lt;String&gt; $method$( final String string )&#10;{&#10;return Option( string ).filter( StringUtils::isNotBlank )&#10;                       .onEmpty( logAtWarningRunnable( &quot;$class$.$method$(empty argument)&quot; ) )&#10;                       .map( logAtDebugUnaryOperator( &quot;$class$.$method$&quot; ) )&#10;                       .map( CheckedFunction1.liftTry( this::$method$_ ) )&#10;                       .peek( t -&gt; t.onFailure( logAtErrorConsumer(&quot;$class$.$method$&quot;) ) ) //.peek( o -&gt; o.recover( logAtErrorFunction( &quot;$class$.$method$&quot; ) ) )&#10;                       .flatMap(t-&gt;Option( t.getOrNull() ));&#10;// todo postcondition check of output result&#10;}&#10;&#10;&#10;&#10;public String $method$_( final String string )&#10;{&#10;//throw new RuntimeException( &quot; cause &quot; );&#10;return &quot;otvet+&quot; + string;&#10;}&#10;" description="VAVR supplier-&gt;try" toReformat="false" toShortenFQNames="true">
    <variable name="class" expression="className()" defaultValue="" alwaysStopAt="false" />
    <variable name="method" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="fx method trampoline" value="//System.out.println( &quot;TRAMPOLINE=&quot; + new App().sum( List.of( 1L , 2L , 3L , 4L ) ) );&#10;&#10;public $Long$ sum( List&lt;$Long$&gt; list )&#10;&#9;{&#10;&#9;return sum( 0L , list ).get();&#10;&#9;}&#10;&#10;&#10;&#10;public Trampoline&lt;$Long$&gt; sum( $Long$ acc ,&#10;&#9;                                  List&lt;$Long$&gt; cnt )&#10;&#9;{&#10;&#9;return cnt.isEmpty() ? done( acc ) : more( () -&gt; sum( acc + cnt.head() , cnt.tail() ) );&#10;&#9;}" description="CYCLOPS supplier-&gt;try" toReformat="false" toShortenFQNames="true">
    <variable name="Long" expression="classNameComplete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
</templateSet>