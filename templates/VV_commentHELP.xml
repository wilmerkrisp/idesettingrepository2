<templateSet group="VV_commentHELP">
  <template name="comment1" value="/**&lt;pre&gt;&#10;       !CHANGE_ME_DESCRIPTION!&#10; &#10;{@code&#10;&#10; example1&#10;&#10; }&#10; &lt;/pre&gt;&#10;   @param p_1 parameter&#10;   @throws NullPointerException if argument nullable&#10;!? @throws IllegalArgumentException if argument empty&#10;!? @return empty value if argument empty&#10;&#10;               ПОМНИ СГЕНЕРИТЬ JAVADOC MAC8+fixDocComment И УБРАТЬ ЭТОТ ТЕКСТ&#10;*/" description="OLD javadoc comment" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="comment2" value="/**&lt;pre&gt;&#10; *      !CHANGE_ME_DESCRIPTION!&#10; *      &#10;* &#10;* {@code&#10;* //example1&#10;* &#10;* &#10;* //example2&#10;* }&#10;* &lt;/pre&gt;                 ПОМНИ СГЕНЕРИТЬ JAVADOC MAC8+fixDocComment И УБРАТЬ ЭТОТ ТЕКСТ&#10;*/ " description="javadoc comment add code example" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="usecoll1" value="/**&lt;pre&gt;&#10; *      !CHANGE_ME_DESCRIPTION!&#10;&#10;*&#10; *&#10; *      CRUD+M&#9;create read update delete merge&#10; *      CAM &#9;collection array map&#10; *      LSQ&#9;&#9;list set queue&#10; *      &#10; *      CLD &#9;linkedList(Dequeue)&#10; *      CSN&#9;treeSet(Navigable)&#10; *      CQD arrayDequeue (Dequeue)&#10; *      MN  treeMap (Navigable)&#10; * &#10; * &#10; * &#10; * &#10; * &#10; * &#10; * &#10; * &#10; * &#10;*       iCollection&#10;*               iList&#10;*               iSet&#10;*                       iSortedSet&#10;*                               iNavigableSet&#10;*               iQueue&#10;*                       iDeque&#10;*&#10;*       iMap&#10;*               iSortedMap&#10;*                       INavigableMap&#10;*&#10;*&#10;*&#10;*&#10;*&#10;*       iCollection- abstractCollection&#10;*               iList - abstractList&#10;*                       abstractSequentialList  - linkedList (от Deque)&#10;*                       arrayList&#10;*               iSet - abstractSet&#10;*               iSortedSet&#10;*                       iNavigableSet - treeSet&#10;*               enumSet&#10;*               hashSet&#10;*                       linkedHashSet (сохраняется порядок ввода элементов)&#10;*               iQueue - abstractQueue&#10;*                       iDeque&#10;*                               arrayDeque&#10;*                       priorityQueue&#10;*&#10;*       iMap&#10;*               iSortedMap&#10;*                       INavigableMap treeMap&#10;*               EnumMap&#10;*               HasmMap&#10;*                       LinkedHashMap&#10;*                       IdentityHashMap&#10;*                       weekHashMap&#10;*&#10;*&#10;*&#10; *  &#10;*&#10; * &#10; *  все устаревшие коллекции синхронизированы&#10; *      Vector          ArrayList&#10;*       Enumeration     Iterator&#10;*       Stack           ArrayDequeue&#10;*       Dictionary      Map&#10;*       HashTable       HsahMap синхр&#10;*       Properties      -..-&#10;*&#10; * &#10; * &#10; * &#10; * &#10; *&#10; &lt;/pre&gt;*/" description="OLD help: COLLECTIONS hierarchy" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="usecoll2" value="&#10;CRUD+M&#9;create read update delete merge&#10;CAM &#9;collection array map&#10;LSQ&#9;&#9;list set queue&#10;&#10;CLD &#9;linkedList(Dequeue)&#10;CSN&#9;treeSet(Navigable)&#10;CSE&#9;enumSet?&#10;CQD arrayDequeue (Dequeue)&#10;MN  treeMap (Navigable)&#10;ME  enumMap?&#10;&#10;&#10;&#10;&#10;COLLECTION INTERFACE (set list queue) hashSet linkedHashSet enumSet&#10;&#9;                                                            C&#10;cc&#9;&#9;add(obj)           &#9;&#9;&#9;&#9;&#9;добавим элементы в конец если объект уже есть то вернуть false&#10;cc    &#9;&#9;addAll(coll)        &#9;&#9;&#9;&#9;&#9;добавим элементы в конец&#10;cc&#9;&#9;toArray()&#9;&#9;&#9;&#9;&#9;&#9;получить немутабельный массив&#10;cc&#9;&#9;toArray(arr)&#9;&#9;&#9;&#9;&#9;&#9;получить немутабельный массив типа arr&#10;R&#10;rc    &#9;&#9;containsAll(coll)   &#9;&#9;&#9;&#9;&#9;содержатся ли все элементы из coll&#10;rc    &#9;&#9;contains(obj)   &#9;&#9;&#9;&#9;&#9;содержится ли элемент obj&#10;rc    &#9;&#9;isEmpty()           &#9;&#9;&#9;&#9;&#9;пусто ли&#10;rc    &#9;&#9;size()              &#9;&#9;&#9;&#9;&#9;length&#10;rc&#9;&#9;iterator()&#9;&#9;&#9;&#9;&#9;&#9;итератор&#10;rc&#9;&#9;spliterator()&#9;&#9;&#9;&#9;&#9;&#9;итератор (используя параллелизм)&#10;rc&#9;&#9;stream()&#9;&#9;&#9;&#9;&#9;&#9;стрим&#10;rc&#9;&#9;parallelStream()&#9;&#9;&#9;&#9;&#9;стрим (используя параллелизм)&#10;U&#10;&#9;&#10;&#9;D&#10;dc    &#9;&#9;clear()             &#9;&#9;&#9;&#9;&#9;удалить все элементы&#10;dc    &#9;&#9;remove(obj)         &#9;&#9;&#9;&#9;&#9;удалить конкретный объект&#10;dc    &#9;&#9;removeAll(coll)     &#9;&#9;&#9;&#9;&#9;удалим элементы&#10;dc    &#9;&#9;retainAll(coll)     &#9;&#9;&#9;&#9;&#9;удаляет все кроме элементов&#10;dc    &#9;&#9;removeIf(predicate) &#9;&#9;&#9;&#9;&#9;удалить объекты удовлетворяющие условию&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;LIST INTERFACE arrayList linkedList&#10;C&#10;ccl   &#9;&#9;add(i,obj)          &#9;&#9;&#9;&#9;&#9;добавить объект по индексу&#10;ccl   &#9;&#9;addAll(i,coll)      &#9;&#9;&#9;&#9;&#9;добавим элементы из коллекции в список по индексу&#10;R&#10;rcl   &#9;&#9;get(i)              &#9;&#9;&#9;&#9;&#9;извлеч объект по индексу&#10;rcl  &#9;&#9;indexOf(obj)        &#9;&#9;&#9;&#9;&#9;извлеч индекс объекта&#10;rcl    &#9;&#9;lastIndexOf(obj)    &#9;&#9;&#9;&#9;&#9;извлеч индекс объекта,ищет с конц&#10;rcl    &#9;&#9;subList[i1,i2)      &#9;&#9;&#9;&#9;&#9;выбрать интервал&#10;rcl&#9;&#9;listIterator()&#9;&#9;&#9;&#9;&#9;&#9;итератор с доп возможностями&#10;rcl&#9;&#9;listIterator(i)&#9;&#9;&#9;&#9;&#9;&#9;итератор, начинается с i-го элемента&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;                                              U&#10;ucl    &#9;set(i,obj)          &#9;&#9;&#9;&#9;&#9;&#9;обновить объект по индексу&#10;ucl    &#9;replaceAll(lambda)  &#9;&#9;&#9;&#9;&#9;        обновить каждый элемент&#10;ucl&#9;&#9;sort(comparator)&#9;&#9;&#9;&#9;&#9;сортировать с помощью компаратора&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;                                         D&#10;dcl    &#9;remove(i)           &#9;&#9;&#9;&#9;&#9;        удалить объект по индексу&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;SET NAVIGABLE treeSet&#10;&#9;              C&#10;&#10;R&#10;rcsn   &#9;first()&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;выбрать первый элемент&#10;rcsn    &#9;last() &#9;&#9;&#9;&#9;&#9;&#9;&#9;выбрать последний элемент&#10;rcsn    &#9;subSet(obj1,obj2)   &#9;&#9;&#9;&#9;&#9;выбрать интервал [obj1..obj2)&#10;rcsn    &#9;headSet(obj2)       &#9;&#9;&#9;&#9;&#9;выбрать интервал [..obj2)&#10;rcsn   &#9;tailSet(obj1)       &#9;&#9;&#9;&#9;&#9;        выбрать интервал (obj1..]&#10;rcsn&#9;&#9;comparator()&#9;&#9;&#9;&#9;&#9;&#9;компаратор отсортированного множества (null если естественное упорядочивание)&#10;&#10;rcsn   &#9;ceiling(obj)        &#9;&#9;&#9;&#9;&#9;        следующий элемент за объектом &gt;=&#10;                                                                                             rcsn    &#9;higher(obj)&#9;&#9;&#9;&#9;&#9;&#9;следующий элемент за объектом &gt;&#10;rcsn   &#9;floor(obj)          &#9;&#9;&#9;&#9;&#9;&#9;предыдущий элемент перед объектом &lt;=&#10;                                                                                                       rcsn  &#9;lower(obj)&#9;&#9;&#9;&#9;&#9;&#9;&#9;предыдущий элемент перед объектом &lt;&#10;rcsn    &#9;subSet(obj1,включительно,obj2,включительно)             выбрать интервал  [obj1..obj2]&#10;rcsn   &#9;headSet(obj2,включительно)       &#9;&#9;                выбрать интервал [..obj2]&#10;rcsn   &#9;tailSet(obj1,включительно)       &#9;&#9;                выбрать интервал [obj1..]&#10;rcsn&#9;&#9;descendingIterator()&#9;&#9;&#9;&#9;&#9;итератор обратного порядка&#10;rcsn&#9;&#9;descendingSet()&#9;&#9;&#9;&#9;&#9;        вернуть множество отсортированное в обратном порядке&#10;U&#10;&#9;&#10;&#9;D&#10;dcsn   &#9;poolFirst()         &#9;&#9;&#9;&#9;&#9;&#9;удалить и вернуть первый элемент&#10;dcsn    &#9;poolLast()          &#9;&#9;&#9;&#9;&#9;удалить и вернуть последний элемент&#10;&#10;&#10;&#10;&#10;&#10;&#10;QUEUE INTERFACE priorityQueue&#10;&#9;                C&#10;ccq    &#9;offer(obj)          &#9;&#9;&#9;&#9;&#9;&#9;добавить с головы&#10;R&#10;rcq    &#9;element()           &#9;&#9;&#9;&#9;&#9;        вернуть с головы или exception&#10;rcq    &#9;peek()              &#9;&#9;&#9;&#9;&#9;&#9;вернуть с головы или null&#10;U&#10;&#9;&#10;&#9;D&#10;dcq    &#9;remove()          &#9;&#9;&#9;&#9;&#9;&#9;вернуть с головы и удалить или exception&#10;dcq    &#9;pool()              &#9;&#9;&#9;&#9;&#9;&#9;вернуть с головы и удалить или null&#10;&#10;&#10;&#10;DEQUE INTERFACE arrayDequeue linkedList&#10;C&#10;ccqd       &#9;addFirst(obj)    &#9;&#9;&#9;&#9;&#9;добавить с головы или exception&#10;ccqd       &#9;push(obj)        &#9;&#9;&#9;&#9;&#9;добавить с головы или exception&#10;ccqd      &#9;offerFirst(obj)  &#9;&#9;&#9;&#9;&#9;добавить с головы или false&#10;ccqd      &#9;addLast(obj)     &#9;&#9;&#9;&#9;&#9;добавить с конца или exception&#10;ccqd      &#9;offerLast(obj)   &#9;&#9;&#9;&#9;&#9;добавить с конца или false&#10;R&#10;rcqd       &#9;peekFirst()     &#9;&#9;&#9;&#9;&#9;вернуть с головы или null&#10;rcqd       &#9;peekLast()      &#9;&#9;&#9;&#9;&#9;вернуть с конца или null&#10;rcqd&#9;&#9;descendingIterator()&#9;&#9;&#9;&#9;&#9;итератор обратного порядка&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;                                           U&#10;&#10;D&#10;dcqd    &#9;poolFirst()     &#9;&#9;&#9;&#9;&#9;вернуть с головы и удалить или null&#10;dcqd    &#9;pop()           &#9;&#9;&#9;&#9;&#9;вернуть с головы и удалить или exception&#10;dcqd    &#9;removeFirst()   &#9;&#9;&#9;&#9;&#9;вернуть с головы и удалить или exception&#10;dcqd      &#9;poolLast()      &#9;&#9;&#9;&#9;&#9;вернуть с конца и удалить или null&#10;dcqd      &#9;removeLast()   &#9;&#9;&#9;&#9;&#9;&#9;вернуть с конца и удалить или exception&#10;dcqd      &#9;removeFirstOccurrence(obj)   &#9;&#9;&#9;        найти и удалить объект или false&#10;dcqd      &#9;removeLastOccurrence(obj)    &#9;&#9;&#9;        найти и удалить объект или false, ищет с конца&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;MAP hashMap linkedHashMap weakHashMap identityHashMap enumMap&#10;C&#10;cm&#9;&#9;computeIfAbsent(key,lambda)  &#9;&#9;&#9;        создать новый из лямбды или вернуть существующий кортеж (lambda=null ничего не делает) {текущее значение не заменяет }&#10;cm&#9;&#9;putIfAbsent(key,value) &#9;&#9;&#9;&#9;        создать новый {текущее значение не заменяет } {но если валуе кортежа было null то заменяет}&#10;cm&#9;&#9;Map.entry(key,value)&#9;&#9;&#9;&#9;&#9;создать один кортеж&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;                                   R&#10;rm &#9;&#9;get(key) &#9;&#9;&#9;&#9;&#9;&#9;извлеч значение по ключу или null&#10;rm &#9;&#9;getOrDefault(key,defaultValue) &#9;&#9;&#9;        извлеч значение по ключу или defaultValue&#10;rm  &#9;&#9;containsKey(key) &#9;&#9;&#9;&#9;&#9;есть ли ключ key&#10;rm  &#9;&#9;containsValue(value) &#9;&#9;&#9;&#9;        есть ли валуе value&#10;rm  &#9;&#9;entrySet() &#9;&#9;&#9;&#9;&#9;&#9;вернуть Set из кортежей Map.Entry&#10;rm  &#9;&#9;keySet() &#9;&#9;&#9;&#9;&#9;&#9;вернуть Set из ключей&#10;rm  &#9;&#9;values() &#9;&#9;&#9;&#9;&#9;&#9;вернуть Collection из значений&#10;rm  &#9;&#9;forEach(лямбда) &#9;&#9;&#9;&#9;&#9;вызывает лямбду для каждого кортежа (удалять нельзя)&#10;rm  &#9;&#9;isEmpty() &#9;&#9;&#9;&#9;&#9;&#9;пусто ли&#10;rm  &#9;&#9;size() &#9;&#9;&#9;&#9;&#9;&#9;&#9;length&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;     &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;                U&#10;&#10;um  &#9;&#9;computeIfPresent(key,lambda)  &#9;&#9;                заменить существующий кортеж на лямбду (lambda=null удаляет) {новый не вставляет}&#10;um&#9;&#9;replace(key,newValue) &#9;&#9;&#9;&#9;        заменить у существующего кортежа только валуе (поиск по key)&#10;um&#9;&#9;replace(key,value,newValue) &#9;&#9;&#9;        заменить у существующего кортежа только валуе (поиск по key-value)&#10;um  &#9;&#9;replaceAll(lambda)  &#9;&#9;&#9;&#9;&#9;вызывает лямбду для каждого кортежа (удалять нельзя) и каждый элемент заменяет на лямбду&#10;&#10;D&#10;dm   &#9;&#9;clear()&#9;&#9;&#9;&#9;&#9;&#9;&#9;удалить все кортежи&#10;dm  &#9;&#9;remove(key)&#9;&#9;&#9;&#9;&#9;&#9;удалить кортеж по ключу&#10;dm   &#9;&#9;remove(key,value) &#9;&#9;&#9;&#9;&#9;удалить существующий кортеж&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;                                                dm&#10;M&#10;mm&#9;&#9;put(key,value) &#9;&#9;&#9;&#9;&#9;&#9;создать новый или заменить существующий кортеж&#10;mm&#9;&#9;putAll(map)  &#9;&#9;&#9;&#9;&#9;&#9;создать новые или заменить существующие кортежи&#10;mm&#9;&#9;compute(key,lambda) &#9;&#9;&#9;&#9;        создать новый из лямбды или заменить существующий кортеж на лямбду (lambda=null удаляет)&#10;mm &#9;&#9;merge(key,value,lambda) &#9;&#9;&#9;&#9;создать новый из параметров или заменить существующий кортеж на лямбду (lambda=null удаляет)&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;MAP SORTED NAVIGABLE treeMap&#10;C&#10;&#9;&#10;&#9;R&#10;rmn    &#9;firstKey()&#9;&#9;&#9;&#9;&#9;&#9;        выбрать первый ключ&#10;rmn    &#9;lastKey() &#9;&#9;&#9;&#9;&#9;&#9;        выбрать последний ключ&#10;rmn    &#9;subMap(key1,key2)   &#9;&#9;&#9;&#9;                выбрать кортежи по ключам [key1..key2)&#10;rmn    &#9;headMap(key2)    &#9;&#9;&#9;&#9;&#9;        выбрать кортежи по ключам [..key2)&#10;rmn    &#9;tailMap(key1)       &#9;&#9;&#9;&#9;&#9;        выбрать кортежи по ключам (key1..]&#10;rmn&#9;comparator()&#9;&#9;&#9;&#9;&#9;                получить компаратор (null если естественное упорядочивание)&#10;&#10;rmn   &#9;navigableKeySet() &#9;&#9;&#9;&#9;&#9;        вернуть NavigableSet из ключей&#10;rmn   &#9;firstEntry()  &#9;&#9;&#9;&#9;&#9;&#9;        выбрать кортеж с первым ключем&#10;rmn   &#9;lastEntry()  &#9;&#9;&#9;&#9;&#9;&#9;        выбрать кортеж с последним ключем&#10;rmn    &#9;ceilingEntry(key)    &#9;&#9;&#9;&#9;&#9;        выбрать кортеж  (следующий ключ за key&gt;=result)&#10;rmn    &#9;ceilingKey(key)    &#9;&#9;&#9;&#9;&#9;        выбрать  следующий ключ за key&gt;=result&#10;rmn    &#9;higherEntry(key)&#9;&#9;&#9;&#9;&#9;        выбрать кортеж  (следующий ключ за key&gt;result)&#10;rmn    &#9;higherKey(key)&#9;&#9;&#9;&#9;&#9;&#9;        выбрать  следующий ключ за key&gt;result&#10;rmn   &#9;floorEntry(key)          &#9;&#9;&#9;&#9;        выбрать кортеж (предыдущий ключ перед result&lt;=key)&#10;rmn    &#9;floorKey(key)          &#9;&#9;&#9;&#9;&#9;        выбрать предыдущий ключ перед  result&lt;=key&#10;rmn    &#9;lowerKey(key)&#9;&#9;&#9;&#9;&#9;&#9;        выбрать предыдущий ключ перед  result&lt;key&#10;rmn    &#9;lowerEntry(key)&#9;&#9;&#9;&#9;&#9;&#9;        выбрать кортеж (предыдущий ключ перед result&lt;key)&#10;rmn    &#9;subMap(key1,включительно=true,key2,включительно=true)           выбрать кортежи по ключам  [key1..key2]&#10;rmn    &#9;headMap(key2,включительно=true)       &#9;&#9;                выбрать кортежи по ключам [..key2]&#10;rmn    &#9;tailMap(key1,включительно=true)       &#9;&#9;                выбрать кортежи по ключам [key1..]&#10;&#10;rmn&#9;&#9;descendingIterator()&#9;&#9;&#9;&#9;        итератор обратного порядка&#10;rmn&#9;&#9;descendingKeySet()&#9;&#9;&#9;&#9;        сет из ключей в обратном порядке&#10;rmn&#9;&#9;descendingMap()&#9;&#9;&#9;&#9;&#9;        мапа в обратном порядке&#10;U&#10;&#9;&#10;&#9;D&#10;dmn   &#9;poolFirstEntry()         &#9;&#9;&#9;&#9;        удалить и вернуть первый кортеж&#10;dmn   &#9;poolLastEntry()          &#9;&#9;&#9;&#9;        удалить и вернуть последний кортеж&#10;&#9;&#9;&#9;&#9;&#9;   &#10;&#9;&#9;&#9;&#9;&#9;   &#10;&#9;&#9;&#9;&#9;&#9;   &#10;&#9;&#9;&#9;&#9;&#9;   &#10;&#9;&#9;&#9;&#9;&#9;   &#10;&#9;&#9;&#9;&#9;&#9;   &#10;&#9;&#9;&#9;&#9;&#9;   &#10;&#9;&#9;&#9;&#9;&#9;   &#10;&#9;&#9;&#9;&#9;&#9;   &#10;&#9;&#9;&#9;&#9;&#9;   &#10;&#9;&#9;&#9;&#9;&#9;   &#10;&#9;&#9;&#9;&#9;&#9;                                                              Arrays&#10;C&#10;ca&#9;&#9;Arrays.fill(arr,obj) &#9;&#9;&#9;&#9;        заполняет весь массив значением obj&#10;ca &#9;&#9;Arrays.fill(arr,i1,i2,obj) &#9;&#9;&#9;        заполняет диапазон массива значением obj&#10;ca&#9;&#9;Arrays.setAll(arr,lambda) &#9;&#9;&#9;        заполняет весь массив значениями лямбды&#10;ca  &#9;&#9;Arrays.parallelSetAll(arr,lambda) &#9;&#9;        заполняет весь массив значениями лямбды (используя параллелизм)&#10;ca  &#9;&#9;Arrays.parallelPrefix(arr, lambda) &#9;&#9;        заполняет весь массив значениями лямбды (накопительная функция)&#10;ca  &#9;&#9;Arrays.parallelPrefix(arr,i1,i2, lambda) &#9;        заполняет весь массив значениями лямбды (накопительная функция) (диапазон)&#10;&#9;&#9;&#9;&#9;                                                                                                                  R&#10;ra&#9;&#9;Arrays.asList(..)&#9;&#9;&#9;&#9;        получить List (немутабельный)&#10;ra&#9;&#9;Arrays.binarySearch(arr,obj) &#9;&#9;&#9;        двоичный поиск индекса obj а отсортированном массиве arr&#10;ra&#9;&#9;Arrays.binarySearch(arr,obj) &#9;&#9;&#9;        двоичный поиск индекса obj а отсортированном массиве arr[i1,i2]&#10;ra&#9;&#9;Arrays.binarySearch(arr,obj,comparator) &#9;        двоичный поиск индекса obj а отсортированном массиве arr(&lt;&gt;версия с компаратором)&#10;ra&#9;&#9;Arrays.binarySearch(arr,i1,i2,obj,comparator) &#9;        двоичный поиск индекса obj а отсортированном массиве arr(&lt;&gt;версия с компаратором) на отрезке [i1,i2]&#10;ra&#9;&#9;Arrays.copyOf(arr,length) &#9;&#9;&#9;        скопировать массив arr&#10;ra   &#9;&#9;Arrays.copyOf(arr,length,newType) &#9;&#9;        скопировать массив arr в массив поддтипа newType&#10;ra  &#9;&#9;Arrays.copyOfRange(arr,i1,i2) &#9;&#9;&#9;        скопировать интервал [i1,i2) массива arr&#10;ra   &#9;&#9;Arrays.copyOfRange(arr,i1,i2,newType) &#9;                скопировать интервал [i1,i2) массива arr в массив оддтипа newType&#10;ra   &#9;&#9;Arrays.equals(arr1,arr2) &#9;&#9;&#9;        поверхностное сравнение = &#10;ra   &#9;&#9;Arrays.equals(arr1,i1,i2,arr2,i1,i2) &#9;&#9;        поверхностное сравнение = отрезка1 и отрезка2&#10;ra   &#9;&#9;Arrays.equals(arr1,arr2,comparator) &#9;&#9;&#9;поверхностное сравнение = (версия с компаратором)&#10;ra   &#9;&#9;Arrays.equals(arr1,i1,i2,arr2,i1,i2,comparator) &#9;поверхностное сравнение = отрезка1 и отрезка2 (версия с компаратором)&#10;ra   &#9;&#9;Arrays.compare(arr1,arr2) &#9;&#9;&#9;        поверхностное сравнение = &lt; &gt;&#10;ra   &#9;&#9;Arrays.compare(arr1,i1,i2,arr2,i1,i2) &#9;&#9;        поверхностное сравнение = &lt; &gt; отрезка1 и отрезка2&#10;ra   &#9;&#9;Arrays.compare(arr1,arr2,comparator) &#9;                поверхностное сравнение = &lt; &gt; (версия с компаратором)&#10;ra   &#9;&#9;Arrays.compare(arr1,i1,i2,arr2,i1,i2,comparator) &#9;поверхностное сравнение = &lt; &gt; отрезка1 и отрезка2 (версия с компаратором)&#10;ra   &#9;&#9;Arrays.mismatch(arr1,arr2) &#9;&#9;&#9;        индекс первого несовпадения при сравнении двух массивов&#10;ra   &#9;&#9;Arrays.mismatch(arr1,i1,i2,arr2,i1,i2) &#9;&#9;        индекс первого несовпадения при сравнении двух отрезков&#10;ra   &#9;&#9;Arrays.mismatch(arr1,arr2,comparator) &#9;&#9;&#9;индекс первого несовпадения при сравнении двух массивов (версия с компаратором)&#10;ra   &#9;&#9;Arrays.mismatch(arr1,i1,i2,arr2,i1,i2,comparator) &#9;индекс первого несовпадения при сравнении двух отрезков (версия с компаратором)&#10;ra   &#9;&#9;Arrays.deepEquals(arr1,arr2) &#9;&#9;&#9;        глубокое сравнение (проверяет также вложенные массивы)&#10;ra&#9;&#9;Arrays.spliterator(arr) &#9;&#9;&#9;&#9;получить сплитератор массива arr&#10;ra  &#9;&#9;Arrays.splitrrator(arr,i1,i2)&#9;&#9;&#9;&#9;получить сплитератор массива arr (версия для выборки поддиапазона)&#10;ra  &#9;&#9;Arrays.stream(arr) &#9;&#9;&#9;&#9;&#9;получить стрим массива arr&#10;ra  &#9;&#9;Arrays.stream(arr,i1,i2)&#9;&#9;&#9;&#9;получить стрим массива arr (версия для выборки поддиапазона)&#10;ra&#9;&#9;Arrays.deepToString() &#9;&#9;&#9;&#9;        глубокая печать&#10;ra  &#9;&#9;Arrays.deepHashCode() &#9;&#9;&#9;&#9;        глубокий хешкод&#10;U&#10;ua&#9;&#9;Arrays.sort(arr) &#9;&#9;&#9;&#9;&#9;сортирует массив по возрастанию&#10;ua  &#9;&#9;Arrays.sort(arr, comparator) &#9;&#9;&#9;        сортирует массив по компаратору&#10;ua&#9;&#9;Arrays.sort(arr,i1,i2) &#9;&#9;&#9;&#9;&#9;сортирует массив по возрастанию (поддиапазон)&#10;ua  &#9;&#9;Arrays.sort(arr, i1,i2,comparator) &#9;&#9;        сортирует массив по компаратору (поддиапазон)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;                                                                                                                                    ua  &#9;&#9;Arrays.sort ?&#9;&#9;&#9;&#9;&#9;&#9;версия для сортировки поддиапазона&#10;ua  &#9;&#9;Arrays.parallelSort(arr) &#9;&#9;&#9;&#9;сортирует массив по возрастанию (используя параллелизм)&#10;ua  &#9;&#9;Arrays.parallelSort(arr, comparator) &#9;&#9;        сортирует массив по компаратору (используя параллелизм)&#10;ua  &#9;&#9;Arrays.parallelSort(arr,i1,i2) &#9;&#9;&#9;&#9;сортирует массив по возрастанию (используя параллелизм) (поддиапазон)&#10;ua  &#9;&#9;Arrays.parallelSort(arr, i1,i2,comparator) &#9;&#9;сортирует массив по компаратору (используя параллелизм) (поддиапазон)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;                                                                                                                                                                                                    D&#10;&#10;&#10;&#10;_______________________ Collections.&#10;&#10;&#10;Collections.&#10;&#9;C&#10;cc&#9;&#9;Collections.addAll(coll,..)&#9;&#9;&#9;&#9;добавить элементы из arr, vararg в coll&#10;cc&#9;&#9;Collections.checkedCollection(coll, elementsType) &#9;получить коллекцию (будет каждый раз внутри CRUD проверять тип элемента ) (only for debug)&#10;cc&#9;&#9;Collections.reverceOrder(comparator)&#9;&#9;&#9;получить компаратор обратный из comparator&#10;cc&#9;&#9;Collections.reverceOrder()&#9;&#9;&#9;&#9;получить компаратор обратный&#10;cc&#9;&#9;Collections.synchronizedCollection(coll)&#9;&#9;получить потокобезопасную коллекцию&#10;Collections.unmodifieble(coll)&#9;&#9;&#9;&#9;&#9;        получить коллекцию (немутабельную)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#10; R&#10;rc&#9;&#9;Collections.disjoint(coll1,coll2)&#9;&#9;&#9;false если у коллекций есть общие элементы&#10;rc&#9;&#9;Collections.frequency(coll,obj)&#9;&#9;&#9;&#9;подсчитывает количество объектов obj в coll&#10;rc&#9;&#9;Collections.max(coll,comparator) &#9;&#9;&#9;найти максимальный элемент в coll по компаратору&#10;rc&#9;&#9;Collections.max(coll)&#9;&#9;&#9;&#9;&#9;найти максимальный элемент в отсортированной coll&#10;rc&#9;&#9;Collections.min(coll,comparator) &#9;&#9;&#9;найти минимальный элемент в coll по компаратору&#10;rc&#9;&#9;Collections.min(coll)&#9;&#9;&#9;&#9;&#9;найти минимальный элемент в отсортированной coll&#10;U&#10;&#9;D&#10;&#10;&#10;&#10;&#10;Collections for list&#10;&#9;                C&#10;&#10;ccl&#9;&#9;Collections.checkedList(list, elementsType) &#9;&#9;получить список (будет каждый раз внутри CRUD проверять тип элемента )(only for debug)&#10;ccl&#9;&#9;Collections.copy(listTo,listFrom)&#9;&#9;        копирует из одного списка в другой&#10;ccl&#9;&#9;Collections.emptyList () &#9;&#9;&#9;&#9;получить список пустой (немутабельный)&#10;ccl&#9;&#9;Collections.emptyListIterator() &#9;&#9;&#9;получить итератор пустой&#10;ccl&#9;&#9;Collections.nCopies(n,obj)&#9;&#9;&#9;&#9;получить список состоящий из n элементов obj&#10;ccl&#9;&#9;Collections.singletonList(obj)&#9;&#9;&#9;&#9;получить список состоящий из одного элемента obj (немутабельный)&#10;ccl&#9;&#9;Collections.synchronizedList(list)&#9;&#9;&#9;получить список (потокобезопасный)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;                                                     ccl&#9;&#9;List.of(..)&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;получить список (немутабельный) из arr или vararg или пустойСписок&#10;ccl&#9;&#9;List.&lt;arrtype[]&gt;of(arr)&#9;&#9;&#9;&#9;&#9;получить список (немутабельный)  &quot;массив массивов&quot;&#10;ccl&#9;&#9;Collections.unmodifiebleList(list)&#9;&#9;&#9;получить список (немутабельный)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;                                                     R&#10;rcl&#9;&#9;Collections.binarySearch(list,obj) &#9;&#9;&#9;двоичный поиск индекса obj а отсортированном списке list&#10;rcl&#9;&#9;Collections.binarySearch(list,obj,comparator) &#9;&#9;двоичный поиск индекса obj а отсортированном списке list(&lt;&gt;версия с компаратором)&#10;rcl&#9;&#9;Collections.IndexOfSubList(list,sublist)&#9;&#9;ищет индекс sublist внутри list&#10;rcl&#9;&#9;Collections.lastIndexOfSubList(list,sublist)&#9;&#9;ищет индекс sublist внутри list, ищет с конца&#10;&#10;U&#10;ucl&#9;&#9;Collections.replaceAll(list,obj,newobj)&#9;&#9;&#9;заменить все вхождения obj на newobj&#10;ucl&#9;&#9;Collections.reverce(list) &#9;&#9;&#9;&#9;заменить на обратный порядок элементов&#10;ucl&#9;&#9;Collections.rotate(list,n)&#9;&#9;&#9;&#9;сдвигает элементы циклически вправо n&gt;0 или влево n&lt;0&#10;ucl&#9;&#9;Collections.shuffle(list, random)&#9;&#9;&#9;перемешивает элементы списка с помощью random&#10;ucl&#9;&#9;Collections.shuffle(list)&#9;&#9;&#9;&#9;перемешивает элементы списка&#10;ucl&#9;&#9;Collections.sort(list,comparator)&#9;&#9;&#9;сортирует список с помощью comparator&#10;ucl&#9;&#9;Collections.sort(list)&#9;&#9;&#9;&#9;&#9;сортирует список (естественное упорядочивание)&#10;ucl&#9;&#9;Collections.swap(list,i1,i2)&#9;&#9;&#9;&#9;меняет элементы с индексами i1,i2 местами&#10;ucl&#9;&#9;Collections.fill(list,obj) &#9;&#9;&#9;&#9;заполняет весь список значением obj&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;                                                                     D&#10;&#10;&#10;&#10;&#10;&#10;Collections for set&#10;&#9;                C&#10;ccs&#9;&#9;Collections.checkedSet(set, elementsType) &#9;&#9;получить сет (будет каждый раз внутри CRUD проверять тип элемента )(only for debug)&#10;ccs&#9;&#9;Collections.checkedNavigableSet(set, elementsType)      получить сет navigable (будет каждый раз внутри CRUD проверять тип элемента )(only for debug)&#10;ccs&#9;&#9;Collections.checkedSortedSet(set, elementsType) &#9;получить сет sorted (будет каждый раз внутри CRUD проверять тип элемента )(only for debug)&#10;ccs&#9;&#9;Collections.emptySet()&#9;&#9;&#9;&#9;&#9;получить сет пустой (немутабельный)&#10;ccs&#9;&#9;Collections.emptyNavigableSet()&#9;&#9;&#9;&#9;получить сет пустой navigable (немутабельный)&#10;ccs&#9;&#9;Collections.emptySortedSet()&#9;&#9;&#9;&#9;получить сет пустой sorted (немутабельный)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;                                                                                                                          ccs&#9;&#9;Collections.newSetFromMap(map)&#9;&#9;&#9;&#9;получить сет из мап&#10;ccs&#9;&#9;Collections.singleton(obj)&#9;&#9;&#9;&#9;получить сет состоящий из одного элемента obj (немутабельный)&#10;ccs&#9;&#9;Collections.synchronizedSet(set)&#9;&#9;&#9;получить сет (потокобезопасный)&#10;ccs&#9;&#9;Collections.synchronizedSortedSet(set)&#9;&#9;&#9;получить сет (потокобезопасный) sorted&#10;ccs&#9;&#9;Collections.synchronizedNavigableSet(set)&#9;&#9;получить сет (потокобезопасный) navigable&#10;ccs&#9;&#9;Set.of(..)&#9;&#9;&#9;&#9;&#9;&#9;получить сет (немутабельный) из arr или vararg или пустойСет&#10;ccs&#9;&#9;Set.&lt;arrtype[]&gt;of(arr)&#9;&#9;&#9;&#9;&#9;получить сет (немутабельный)  &quot;массив массивов&quot;&#10;ccs&#9;&#9;Collections.unmodifiebleNavigableSet(set)&#9;&#9;получить сет (немутабельный) navigable&#10;ccs&#9;&#9;Collections.unmodifiebleSet(set)&#9;&#9;&#9;получить сет (немутабельный)&#10;ccs&#9;&#9;Collections.unmodifiebleSortedSet(set)&#9;&#9;&#9;получить сет sorted (немутабельный)&#10;R&#10;&#9;&#10;&#9;U&#10;D&#10;&#10;&#10;&#10;&#10;Collection for queue&#10;&#9;               C&#10;ccq&#9;&#9;Collections.asLifoQieue(dequeue) &#9;&#9;&#9;получить стек LIFO&#10;ccq&#9;&#9;Collections.checkedQueue (queue, elementsType) &#9;        получить кью (будет каждый раз внутри CRUD проверять тип элемента )(only for debug)&#10;R&#10;&#9;&#10;&#9;U&#10;D&#10;&#10;&#10;&#10;&#10;Collections for Map&#10;&#9;                C&#10;cm&#9;&#9;Collections.checkedMap(map, keyType,valueType) &#9;&#9;получить мапу (будет каждый раз внутри CRUD проверять тип элемента )(only for debug)&#10;cm&#9;&#9;Collections.checkedNavigableMap(map, keyType,valueType) получить мапу navigable (будет каждый раз внутри CRUD проверять тип )(only for debug)элемента )&#10;cm&#9;&#9;Collections.checkedSortedMap(map, keyType,valueType) &#9;получить мапу sorted (будет каждый раз внутри CRUD проверять тип элемента )(only for debug)&#10;cm&#9;&#9;Collections.emptyMap() &#9;&#9;&#9;&#9;&#9;получить мапу пустую (немутабельную)&#10;cm&#9;&#9;Collections.emptySortedMap() &#9;&#9;&#9;&#9;получить мапу пустую (немутабельную) sorted&#10;cm&#9;&#9;Collections.singletonMap(key,value)&#9;&#9;&#9;получить мапу состоящую из одного кортежа key-value (немутабельную)&#10;cm&#9;&#9;Collections.synchronizedMap(map)&#9;&#9;&#9;получить мапу потокобезопасную&#10;cm&#9;&#9;Collections.synchronizedNavigableMap(map)&#9;&#9;получить мапу потокобезопасную navigable&#10;cm&#9;&#9;Collections.synchronizedSortedMap(map)&#9;&#9;        получить мапу потокобезопасную sorted&#10;ccs&#9;&#9;Map.of(key,value,key,value)&#9;&#9;&#9;&#9;получить мапу (немутабельную)  key-value или пустаяМапа&#10;ccs&#9;&#9;Map.ofEntries(arr)&#9;&#9;&#9;&#9;&#9;получить мапу (немутабельную) из arr или vararg (ЭЛЕМЕНТЫ ТИПА Map.Entry)&#10;cm&#9;&#9;Collections.unmodifiebleMap(map)&#9;&#9;&#9;получить мапу (немутабельную)&#10;cm&#9;&#9;Collections.unmodifiebleNavigableMap(map)&#9;&#9;получить мапу (немутабельную) navigable&#10;cm&#9;&#9;Collections.unmodifiebleSortedMap(map)&#9;&#9;&#9;получить мапу (немутабельную) sorted&#10;R&#10;&#9;&#10;&#9;U&#10;D&#10;&#10;&#9;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;" description="help: COLLECTIONS work" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="method main" value="&#10;&#10;static&#10;&#9;{&#10;&#9;InputStream stream = Main.class.getClassLoader()&#10;&#9;                               .getResourceAsStream( &quot;logging.properties&quot; );&#10;&#9;FileHelper.ioWrapper( () -&gt; LogManager.getLogManager()&#10;&#9;                                      .readConfiguration( stream ) , &quot;No src/main/resources/logging.properties!&quot; );&#10;&#9;}&#10;private static final FluentLogger logger_ = FluentLogger.forEnclosingClass();&#10;&#10;&#10;&#10;private static final ResourceBundle bundle_ = ResourceBundle.getBundle( &quot;messages&quot; );&#10;&#10;&#10;&#10;private static final String START_MESSAGE_ = bundle_.getString( &quot;startProgram&quot; );&#10;&#10;/**&lt;pre&gt;&#10; *      main class&#10; *      !CHANGE_ME_DESCRIPTION!&#10; * &#10; *  &#10; *&#10; *        0) пакет задать life.expert.algo.research.base&#10; * &#10; *       0) change   rootProject.name  in settings.gradle&#10; * &#10; * &#9; 0) изменим gradle-&gt;use gradle wrapper task configuration&#10; * &#9; &#10; * &#9;  0) ./gradlew wrapper&#10; *&#10; * &#10; *      1) создадим новый проект&#10;*               в настройках IDEA select code style = выберем мою схему&#10; *               &#10; *      4) добавим пакеты life.expert.mainpack и класс VV_main &#10; *      &#10;*       2) добавим поддержку мевена&#10;*               клик на project -&gt; add framework support = maven&#10; *              ОБЯЗАТЕЛЬНО НАЖАТЬ В ПРАВОМ НИЖНЕМ УГЛУ В ВЫСКОЧИВШЕМ ОКНЕ enable auto import &#10; *              помести внутрь тегов в помке снипет maven&#10; *              &#10;       7) добавим файл src/main/java/resources/log4j2.xml&#10; *               &#10;*       3) добавим metainf&#10;*               cmd+; -&gt; artifacts -&gt; jar -&gt; from modules -&gt; директорию выберем resources&#10;*               (или перетащить мышкой meta-inf в подпапку resources&#10; *               &#10;*       5) создать конфигурацию &quot;Application&quot; для запуска&#10;*               выбрать главный класс для запуска&#10; *               &#10; *      6) проверим: сбилдим цель и провери мавенBUILD  &#10;&#10; *&#10; &lt;/pre&gt;*/&#10; &#10;public static void main(final String ... p_i )&#10;{&#10;//System.out.println( &quot;VV_main main &quot; );&#10;log.info( &quot;_________start_programm_________________________&quot; );&#10;&#10;$END$&#10;}&#10;&#10;" description="class method / start application" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="comment folding" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/* $END$&#10;&#10;$SELECTION$&#10;&#10;*/&#10;//&lt;/editor-fold&gt;&#10;&#10;" description="folding region comment !add empty line after comment" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="comment immutable deprecated method" value="/**&#10; *   deprecated for immutable   &#10;*/&#10;@Override&#10;@Deprecated&#9;" description="javadoc comment" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="code comment" value="{@code $SELECTION$ }" description="code formatting" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="folding format off" value="//@formatter:off&#10;$END$&#10;$SELECTION$&#10;//@formatter:on&#10;&#10;&#10;" description="disable autoformat for code block" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="code comment PRE" value="&lt;pre&gt;{@code $SELECTION$ }&lt;/pre&gt;" description="code formatting with PRE tag" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="comment folding 2" value="//&lt;editor-fold desc=&quot;$END$&quot;&gt;&#10; &#10;//&lt;/editor-fold&gt;&#10;&#10;" description="no comment" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
</templateSet>