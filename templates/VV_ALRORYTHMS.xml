<templateSet group="VV_ALRORYTHMS">
  <template name="method algo recursion1" value="&#9;/**&#10;&#9; * &#10;&#9; *      !CHANGE_ME_DESCRIPTION!&#10;&#9; * &#10;&#9; * &lt;pre&gt;{@code                   method simple recursia&#10;&#9; *&#10;&#9; * example 1&#10;&#9; *           v_obj.f_recursiveMethodd(10);&#10;&#9; *&#10;&#9; * example 2&#10;&#9; *&#10;&#9; *&#10;&#9; * }&lt;/pre&gt;&#10;&#9; *&#10;&#9; *&#10;&#9; */&#10;&#9;public static void f_recursiveMethodd(final int p_1 )&#10;&#9;&#9;{&#10;&#9;&#9;log_.debug( &quot;${PROJECT_NAME} ${PACKAGE_NAME} recursia start      : &quot; + p_1 );&#10;&#9;&#9;if( p_1 &gt; 0 )&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;f_recursiveMethodd( p_1-1 );&#10;&#9;&#9;&#9;}&#10;&#9;&#9;log_.debug( &quot;${PROJECT_NAME} ${PACKAGE_NAME} recursia end        : &quot; + p_1 );&#10;&#9;&#9;}&#10;" description="method recursia" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="methods algo thread1" value="package com.wilmer.clock;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;import org.apache.log4j.Logger;&#10;&#10;//&#10;//                          Vladimir Krupskiy (wilmer)&#10;//                          jjtest com.wilmer.clock&#10;//                          13.12.17 21:08&#10;// &#10;//&#10;//  Naming convention:&#10;//  *_isMethod&#9;return bool&#10;//  *_ref&#9;&#9;return ref&#10;//  *_should_&#9;event handling: if possible handle&#10;//  *_will_&#9;&#9;event handling: will handle&#10;//  *_did_&#9;&#9;event handling: did handle&#10;//&#10;//  VC_&#9;&#9;    class&#10;//  VV_         class non mutable value&#10;//  VI_&#9;&#9;    interface&#10;//  VA_&#9;&#9;    abstract class&#10;//  VS_         static class&#10;//  VE_&#9;&#9;    enum&#10;//  VX_         exception&#10;//  VT_         thread&#10;//  *_shared_&#9;singleton&#10;//&#10;//  g_&#9;&#9;    global or static&#10;//  c_&#9;&#9;    class poroperty&#10;//  p_&#9;&#9;    method parameter&#10;//  f_&#9;&#9;    class method&#10;//  v_&#9;&#9;    variable&#10;//  l_&#9;&#9;    lazy load&#10;//  _inBlock&#9;variables inside lambda&#10;//&#10;//&#10;&#10;&#10;&#10;&#10;/**&#10; * class simple&#10; *&#10; * &lt;pre&gt;{@code&#10; *&#10; * example 1&#10; *              VC_clock v_obj = new VC_clock();&#10; *              v_obj.f_test();&#10; *&#10; * example 2&#10; *              ВЫЗЫВАЯ МЕТОДЫ ТИК-ТАК ЭТОГО ОБЪЕКТА В ЛЮБОМ ПОРЯДКЕ, ОНИ ВСЕ РАВНО БУДУТ РАБОТАТЬ ПО ОЧЕРЕДИ&#10; *              вызов из одного потока c_clock.f_tik();&#10; *              вызов из другого потока c_clock.f_tak();&#10; *&#10; * }&lt;/pre&gt;&#10; */&#10;/*public protected-default final       implements VI_ extends VV_   */&#10;public class VC_clock&#10;&#9;{&#10;&#9;&#10;&#9;&#10;&#9;//////////////////////////////////////////////////////////////////////////////////&#10;&#9;//&#10;&#9;//                              variables&#10;&#9;//&#10;&#9;//////////////////////////////////////////////////////////////////////////////////  &#10;&#9;/**&#10;&#9; * log4j debug massage&#10;&#9; *&#10;&#9; * &lt;pre&gt;{@code&#10;&#9; *&#10;&#9; * example 1&#10;&#9; *           log.debug   ( &quot;jjtest com.wilmer.clock VC_clock  &quot; );&#10;&#9; * &#9;        log.info    ( &quot;jjtest com.wilmer.clock VC_clock  &quot; );&#10;&#9; * &#9;        log.warn    ( &quot;jjtest com.wilmer.clock VC_clock  &quot; );&#10;&#9; * &#9;        log.error   ( &quot;jjtest com.wilmer.clock VC_clock  &quot; );&#10;&#9; *&#10;&#9; * example 2&#10;&#9; *&#10;&#9; *&#10;&#9; * }&lt;/pre&gt;&#10;&#9; */&#10;&#9;private static final Logger log_ = Logger.getLogger( VC_clock.class );&#10;&#9;&#10;&#9;/**&#10;&#9; * variable test&#10;&#9; *&#10;&#9; * &lt;pre&gt;{@code&#10;&#9; *&#10;&#9; * example 1&#10;&#9; *           this.c_test&#10;&#9; *&#10;&#9; * example 2&#10;&#9; *&#10;&#9; *&#10;&#9; * }&lt;/pre&gt;&#10;&#9; */&#10;&#9;private String c_test = &quot;init&quot;;                     /* private public protected final */&#10;&#9;&#10;&#9;&#10;&#9;/**&#10;&#9; * variable test&#10;&#9; *&#10;&#9; * &lt;pre&gt;{@code&#10;&#9; *&#10;&#9; * example 1&#10;&#9; *           this.c_test&#10;&#9; *&#10;&#9; * example 2&#10;&#9; *&#10;&#9; *&#10;&#9; * }&lt;/pre&gt;&#10;&#9; */&#10;&#9;private boolean c_tik = true;                     /* private public protected final */&#10;&#9;&#10;&#9;&#10;&#9;//////////////////////////////////////////////////////////////////////////////////&#10;&#9;//&#10;&#9;//                              methods&#10;&#9;//&#10;&#9;//////////////////////////////////////////////////////////////////////////////////  &#10;&#9;&#10;&#9;&#10;&#9;&#10;&#9;&#10;&#9;/**&#10;&#9; * constructor default&#10;&#9; *&#10;&#9; * &lt;pre&gt;{@code&#10;&#9; *&#10;&#9; * exapmle 1&#10;&#9; *           VC_clock v_obj = new VC_clock();&#10;&#9; *&#10;&#9; * example 2&#10;&#9; *&#10;&#9; *&#10;&#9; * }&lt;/pre&gt;&#10;&#9; */&#10;&#9;public VC_clock( )                           /* private public protected   throws Exception */&#10;&#9;&#9;{&#10;&#9;&#9;//super();&#10;&#9;&#9;log_.debug( &quot;jjtest com.wilmer.clock VC_clock  init: &quot; );&#10;&#9;&#9;&#9;&#10;&#9;&#9;}&#10;&#9;&#10;&#9;&#10;&#9;&#10;&#9;&#10;&#9;/**&#10;&#9; * constructor with parameter&#10;&#9; *&#10;&#9; * &lt;pre&gt;{@code&#10;&#9; *&#10;&#9; * exapmle 1&#10;&#9; *           VC_clock v_obj = new VC_clock(&quot;param&quot;);&#10;&#9; *&#10;&#9; * example 2&#10;&#9; *&#10;&#9; *&#10;&#9; * }&lt;/pre&gt;&#10;&#9; */&#10;&#9;public VC_clock( final String p_1 )                 /* private public protected   throws Exception */&#10;&#9;&#9;{&#10;&#9;&#9;//super(p_1);&#10;&#9;&#9;c_test = p_1;&#10;&#9;&#9;}&#10;&#9;&#10;&#9;//////////////////////////////////////////////////////////////////////////////////&#10;&#9;//&#10;&#9;//                              methods&#10;&#9;//&#10;&#9;//////////////////////////////////////////////////////////////////////////////////  &#10;&#9;&#10;&#9;&#10;&#9;&#10;&#9;&#10;&#9;/**&#10;&#9; * method test&#10;&#9; *&#10;&#9; * &lt;pre&gt;{@code&#10;&#9; *&#10;&#9; * example 1&#10;&#9; *           v_obj.f_test();&#10;&#9; *&#10;&#9; * example 2&#10;&#9; *&#10;&#9; *&#10;&#9; * }&lt;/pre&gt;&#10;&#9; */&#10;&#9;public void f_test( )                    /* private public protected final  throws Exception */&#10;&#9;&#9;{&#10;&#9;&#9;//throw new Exception( &quot;vError&quot; );&#10;&#9;&#9;log_.debug( &quot;jjtest com.wilmer.clock VC_clock  f_test: &quot; );&#10;&#9;&#9;//&#10;&#9;&#9;&#10;&#9;&#9;//&#10;&#9;&#9;return;&#10;&#9;&#9;}&#10;&#9;&#10;&#9;&#10;&#9;&#10;&#9;&#10;&#9;/**&#10;&#9; * method test&#10;&#9; *&#10;&#9; * &lt;pre&gt;{@code&#10;&#9; *&#10;&#9; * example 1&#10;&#9; *           v_obj.f_test();&#10;&#9; *&#10;&#9; * example 2&#10;&#9; *&#10;&#9; *&#10;&#9; * }&lt;/pre&gt;&#10;&#9; */&#10;&#9;&#10;&#9;synchronized public void f_tik( )                    /* private public protected final  throws Exception */&#10;&#9;&#9;{&#10;&#9;&#9;//throw new Exception( &quot;vError&quot; );&#10;&#9;&#9;log_.debug( &quot;jjtest com.wilmer.clock VC_clock  TIK: &quot; );&#10;&#9;&#9;&#10;&#9;&#9;try&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;//&#10;&#9;&#9;&#9;if( c_tik )&#10;&#9;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;c_tik = false;&#10;&#9;&#9;&#9;&#9;notify( );&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;while( !c_tik )&#10;&#9;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;wait( );&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;catch( final InterruptedException p_exception )&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;log_.error( &quot;jjtest com.wilmer.clock VT_tick  Thread interrupted: &quot;  );&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#10;&#9;&#9;&#10;&#9;&#9;//&#10;&#9;&#9;return;&#10;&#9;&#9;}&#10;&#9;&#10;&#9;&#10;&#9;&#10;&#9;&#10;&#9;/**&#10;&#9; * method test&#10;&#9; *&#10;&#9; * &lt;pre&gt;{@code&#10;&#9; *&#10;&#9; * example 1&#10;&#9; *           v_obj.f_test();&#10;&#9; *&#10;&#9; * example 2&#10;&#9; *&#10;&#9; *&#10;&#9; * }&lt;/pre&gt;&#10;&#9; */&#10;&#9;&#10;&#9;synchronized public void f_tak( )                    /* private public protected final  throws Exception */&#10;&#9;&#9;{&#10;&#9;&#9;//throw new Exception( &quot;vError&quot; );&#10;&#9;&#9;log_.debug( &quot;jjtest com.wilmer.clock VC_clock  TAK: &quot; );&#10;&#9;&#9;&#10;&#9;&#9;try&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;//&#10;&#9;&#9;&#9;if( !c_tik )&#10;&#9;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;c_tik = true;&#10;&#9;&#9;&#9;&#9;notify( );&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;while( c_tik )&#10;&#9;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;wait( );&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;catch( final InterruptedException p_exception )&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;log_.error( &quot;jjtest com.wilmer.clock VT_tick  Thread interrupted: &quot; );&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#10;&#9;&#9;&#10;&#9;&#9;//&#10;&#9;&#9;return;&#10;&#9;&#9;}&#10;&#9;&#9;&#10;&#9;&#9;&#10;&#9;}&#10;" description="thread tik tak algo demo" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="func algo regexp1" value="System.out.println( &quot;____________&quot; );&#10;var v_i=0;&#10;var v_buf    = new StringBuffer( );&#10;var      v_regex  =Pattern.compile( &quot;\\w+&quot; );&#10;var      v_finder =v_regex.matcher( &quot; preved vova alsu my &quot; );&#10;while(v_finder.find())&#10;&#9;{&#10;&#9;System.out.println( &quot;_________  ___&quot; );&#10;&#9;System.out.println( &quot;grp:&quot;+ v_finder.group());&#10;&#9;System.out.println( &quot;buf1:&quot;+ v_buf);&#10;&#9;v_finder.appendReplacement(v_buf,String.valueOf( v_i++ )  );&#10;&#9;System.out.println( &quot;buf2:&quot;+ v_buf);&#10;&#9;};&#10;v_finder.appendTail(v_buf );&#10;System.out.println( &quot;buf2_ITOG:&quot;+ v_buf);" description="method regexp find in string" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_EXPRESSION" value="true" />
      <option name="JAVA_STATEMENT" value="true" />
    </context>
  </template>
  <template name="func algo regexp2" value="/**&#10; * asPredicate проверяет что строка или часть строки соответствует шаблону (работает как s -&gt; this.matcher(s).find())&#10; * asMatchPredicate проверяет что вся строка соответствует шаблону (работает как s -&gt; this.matcher(s).matches())&#10; * */&#10;Pattern nonWordCharacter = Pattern.compile(&quot;\\W&quot;);&#10;Stream&#10;&#9;.of(&quot;Metallica&quot;, &quot;Motörhead&quot;)&#10;&#9;.filter(nonWordCharacter.asPredicate())&#10;&#9;.forEach(System.out::println);" description="method regexp find in string" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_EXPRESSION" value="true" />
      <option name="JAVA_STATEMENT" value="true" />
    </context>
  </template>
  <template name="func SWAP int values" value="int a=start;&#10;int b=end;&#10;&#10;if(a&gt;b)&#10;&#9;{&#10;&#9;// Swap start and end&#10;&#9;a=a^b;&#10;&#9;b=a^b;&#10;&#9;a=a^b;&#10;&#9;}" description="method" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="forstream MAX" value="var source = new ArrayList&lt;Integer&gt;( List.of( 10 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) );&#10;var sorted = new ArrayList&lt;Integer&gt;();&#10;Optional&lt;Integer&gt; max=Optional.empty();&#10; &#10;max=source.stream().collect( minBy( Comparator.naturalOrder() ) );&#10;max.ifPresent( sorted::add );" description="stream().collect( minBy( Comparator.naturalOrder() ) );" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_EXPRESSION" value="true" />
      <option name="JAVA_STATEMENT" value="true" />
    </context>
  </template>
  <template name="set algo set intersect" value="var intersect = Sets.intersection( station_cover_towns_immutable.get( &quot;one&quot; ) , neddable ); // guava&#10;//var intersect = SetUtils.intersection( station_cover_towns_immutable.get( &quot;one&quot; ) , neddable ); //apache commons" description="ts intersection" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_EXPRESSION" value="true" />
      <option name="JAVA_STATEMENT" value="true" />
    </context>
  </template>
  <template name="forstream MAX max custom comparator" value="//@formatter:off&#10;&#9;&#9;&#9;var station_cover_towns_immutable = Map.&lt;String,Set&lt;String&gt;&gt;of(&#10;&#9;&#9;&#9;&#9;&quot;one&quot; , Set.&lt;String&gt;of( &quot;Moscow&quot; , &quot;London&quot; , &quot;Singapoor&quot; ) ,&#10;&#9;&#9;&#9;&#9;&quot;two&quot; , Set.&lt;String&gt;of( &quot;CyberJay&quot; , &quot;NewYork&quot; , &quot;SanFrancisco&quot; ) );&#10;&#9;&#9;&#9;//@formatter:on&#10;var station_cover_towns = new HashMap&lt;&gt;( station_cover_towns_immutable );&#10;var neddable            = Set.&lt;String&gt;of( &quot;NewYork1&quot; );&#10;&#10; &#10;&#10;Optional&lt;Map.Entry&lt;String,Set&lt;String&gt;&gt;&gt; max = Optional.empty();&#10; &#10;&#10;var comparator1 = new Comparator&lt;Map.Entry&lt;String,Set&lt;String&gt;&gt;&gt;()&#10;&#9;{&#10;&#9;@Override&#10;&#9;public int compare( final Map.Entry&lt;String,Set&lt;String&gt;&gt; o1 ,&#10;&#9;                    final Map.Entry&lt;String,Set&lt;String&gt;&gt; o2 )&#10;&#9;&#9;{&#10;&#9;&#9;return 0;&#10;&#9;&#9;}&#10;&#9;};&#10;&#10;Comparator&lt;Map.Entry&lt;String,Set&lt;String&gt;&gt;&gt; comparator2 = Comparator.comparing( p -&gt; SetUtils.intersection( p.getValue() , neddable )&#10;                                                                                           .size() );&#10;&#10;max = station_cover_towns.entrySet()&#10;                         .stream()&#10;                         .collect( maxBy( comparator2 ) );&#10; &#10;&#10;System.out.println( &quot;Result &quot; + max );" description="comparator=anonym object" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_EXPRESSION" value="true" />
      <option name="JAVA_STATEMENT" value="true" />
    </context>
  </template>
  <template name="new int" value="&#9;public static final BigInteger big( String number )&#10;&#9;&#9;{&#10;&#9;&#9;return new BigInteger( number );&#10;&#9;&#9;}&#10;&#9;&#10;&#9;public static final BigInteger big( long number )&#10;&#9;&#9;{&#10;&#9;&#9;return BigInteger.valueOf( number );&#10;&#9;&#9;}" description="BigInteger" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="for WHILE POP + result" value="var q   = new ArrayDeque&lt;Integer&gt;( $arr$ );&#10;var result = new ArrayList&lt;Integer&gt;();&#10;while( !q.isEmpty() )&#10;&#9;{&#10;&#9;var fst = q.peekFirst();&#10;&#9;var lst = q.peekLast();&#10;&#9;result.add( 0, q.pollLast() );&#10;&#9;}&#10;print( result );$END$" description="while poolLast" toReformat="false" toShortenFQNames="true">
    <variable name="arr" expression="iterableVariable()" defaultValue="arr" alwaysStopAt="true" />
    <context>
      <option name="JAVA_EXPRESSION" value="true" />
      <option name="JAVA_STATEMENT" value="true" />
    </context>
  </template>
  <template name="for WHILE POPLEFT + result" value="var q   = new ArrayDeque&lt;Integer&gt;( $arr$ );&#10;var result = new ArrayList&lt;Integer&gt;();&#10;while( !q.isEmpty() )&#10;&#9;{&#10;&#9;var fst = q.peekFirst();&#10;&#9;var lst = q.peekLast();&#10;&#9;result.add( q.pollFirst() );&#10;&#9;}&#10;print( result );$END$&#10;&#9;&#9;&#9;" description="while pollFirst" toReformat="false" toShortenFQNames="true">
    <variable name="arr" expression="iterableVariable()" defaultValue="arr" alwaysStopAt="true" />
    <context>
      <option name="JAVA_EXPRESSION" value="true" />
      <option name="JAVA_STATEMENT" value="true" />
    </context>
  </template>
  <template name="forcoll6 list CLASSIC with index" value="for (var i = 0; i &lt; $LIST$.size(); i++) &#10;&#9;{&#10;&#9;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;&#9;/* &#10;&#9; if(v_i == 10) break continue&#10;&#9; log_.debug   (&quot;$class$ $method$ for: &quot;+v_i+&quot;=&quot;+v_j);&#10;&#9; &#10;         C     &#10;&#9; R      $ELEMENT_TYPE$   &#10;&#9; U     &#10;&#9; D&#10;&#9; */&#10;&#9;//&lt;/editor-fold&gt;&#10;&#9;&#10;&#9;&#10;&#9;&#10;        var v_j = $CAST$ $LIST$.get(i);&#10;&#9;&#10;&#9;&#10;&#9;$SELECTION$&#10;&#9;&#9;&#10;&#10;&#9; $END$&#10;&#9;}&#10;&#10;&#10;" description="for(;size();)" toReformat="false" toShortenFQNames="true">
    <variable name="LIST" expression="variableOfType(&quot;java.util.List&quot;)" defaultValue="&quot;list&quot;" alwaysStopAt="true" />
    <variable name="class" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="method" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="ELEMENT_TYPE" expression="guessElementType(LIST)" defaultValue="&quot;Object&quot;" alwaysStopAt="false" />
    <variable name="CAST" expression="castToLeftSideType()" defaultValue="" alwaysStopAt="false" />
    <context>
      <option name="GROOVY_STATEMENT" value="true" />
      <option name="JAVA_STATEMENT" value="true" />
    </context>
  </template>
  <template name="new int INFINITE NUMBER" value="private static final int  INFINITY = Short.MAX_VALUE; // INF only for Integers because of int/2&#10;Integer.MAX_VALUE // !!! НО ПРИ ВЫЧИТАНИИ МАКСИМУМА БУДЕТ ПРОБЛЕМА !!!&#10;Double.POSITIVE_INFINITY" description="Integer.MAX_VALUE" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="for SORT by key" value="$points$.sort( Ordering.natural()&#10;&#9;&#9;                     .onResultOf( p -&gt; (Comparable) p._1 $END$ ) );&#10;&#9;&#9; " description=".sort ( guava comparator )" toReformat="false" toShortenFQNames="true">
    <variable name="points" expression="iterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="for MIN by key" value="var max_ = Collections.max( $points$, Ordering.natural()&#10;                                            .onResultOf( p -&gt; (Comparable) p._1 $END$ ) );" description="Collections.max( guava comparator )" toReformat="false" toShortenFQNames="true">
    <variable name="points" expression="iterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="forstream LISTS CONCATENTION" value="var result=Stream.of( $left$ , $mid$ , $right$ )&#10;             .sequential()&#10;             .flatMap( Collection::stream )&#10;             .collect( toList() );&#10;&#9;&#9; " description="Stream.of(list1,list2,list3)" toReformat="false" toShortenFQNames="true">
    <variable name="left" expression="iterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="mid" expression="iterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="right" expression="iterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="for LISTS CONCATENTION" value="var rez = $left$;&#10;rez.addAll( $mid$ );&#10;rez.addAll($right$ );&#9;&#9; " description="list.addAll( list2 )" toReformat="false" toShortenFQNames="true">
    <variable name="left" expression="iterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="mid" expression="iterableVariable()" defaultValue="" alwaysStopAt="true" />
    <variable name="right" expression="iterableVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="new int random number" value="new Random().nextInt(1000); // [0,999]" description="Integer.MAX_VALUE" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="if EVEN ODD" value="int a = 0;&#10;int b = 11;//not inclusive&#10;int mid=(b-a)%2==0? (b-a)/2-1:(b-a)/2;" description="(b-a)%2==0?" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
  <template name="method graph algo 2" value="public static final int compute$One$( Map&lt;Integer,List&lt;Integer&gt;&gt; graph )&#10;{&#10;if( graph.size() &lt; 2 )&#10;&#9;{&#10;&#9;logAtWarning( &quot;distance: string param must not ne null or empty&quot; );&#10;&#9;return 0;&#10;&#9;}&#10;&#10;var q         = new ArrayDeque&lt;Integer&gt;();&#10;var processed = new HashSet&lt;Integer&gt;();&#10;&#10;Consumer&lt;Integer&gt; process = ( vertex ) -&gt;&#10;{&#10;if( processed.contains( vertex ) )&#10;&#9;return;&#10;processed.add( vertex );&#10;q.addFirst( vertex );&#10;println(&quot;processed=&quot;+vertex);&#10;};&#10;&#10;process.accept( graph.keySet()&#10;                     .iterator()&#10;                     .next() );&#10;&#10;while( !q.isEmpty() )&#10;&#9;{&#10;&#9;var v = q.pollLast();&#10;&#9;for( var e : graph.get( v ) )&#10;&#9;&#9;{&#10;&#9;&#9;process.accept( e );&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;return 0;&#10;}&#10;&#10;&#10;public static final int compute( Map&lt;Integer,List&lt;Integer&gt;&gt; graph )&#10;{&#10;return compute$One$( graph );&#10;}&#10;    &#10;    /*&#10;&#9;@Test&#10;&#9;void compute$One$Test()&#10;&#9;&#9;{&#10;&#9;&#9;&#10;&#9;&#9;//@formatter:off&#10;&#9;&#9;var graph_directed = Map.&lt;Integer,List&lt;Integer&gt;&gt;of( 1, List.&lt;Integer&gt;of( 2, 3 ),&#10;&#9;&#9;                                                    2, List.&lt;Integer&gt;of( 3, 4 ),&#10;&#9;&#9;                                                    3, List.&lt;Integer&gt;of( 4 ),&#10;&#9;&#9;                                                    4, List.&lt;Integer&gt;of() );&#10;&#9;&#9;//@formatter:on&#10;&#9;&#9;&#10;&#9;&#9;System.out.println( &quot;BreadthFirstSearchTest computeOneTest &quot; + compute( graph_directed ) );&#10;&#9;&#9;&#10;&#9;&#9;}&#10;    */" description="BFS breadth first search" toReformat="false" toShortenFQNames="true">
    <variable name="One" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="method graph algo BFS" value="public static final Map&lt;Integer,Integer&gt; $One$( Map&lt;Integer,List&lt;Integer&gt;&gt; graph )&#10;{&#10;&#9;if( graph.size() &lt; 2 )&#10;&#9;&#9;{&#10;&#9;&#9;logAtWarning( &quot;distance: string param must not ne null or empty&quot; );&#10;&#9;&#9;return Map.&lt;Integer,Integer&gt;of();&#10;&#9;&#9;}&#10;&#9;&#10;&#9;var q         = new ArrayDeque&lt;Integer&gt;();&#10;&#9;var processed = new HashSet&lt;Integer&gt;();&#10;&#9;var result         = new HashMap&lt;Integer,Integer&gt;();&#10;&#9;var start_vertex = 1;&#10;&#9;&#10;&#9;&#10;&#9;Predicate&lt;Integer&gt; process = ( vertex ) -&gt;&#10;&#9;&#9;{&#10;&#9;&#9;if( processed.contains( vertex ) )&#10;&#9;&#9;&#9;return false;&#10;&#9;&#9;processed.add( vertex );&#10;&#9;&#9;q.addFirst( vertex );&#10;&#9;&#9;return true;&#10;&#9;&#9;};&#10;&#10;&#9;println( &quot;startvertex not processed=&quot; + start_vertex );&#10;&#9;process.test( start_vertex );&#10;&#9;&#10;&#9;while( !q.isEmpty() )&#10;&#9;&#9;{&#10;&#9;&#9;var v = q.pollLast();&#10;&#9;&#9;for( var e : graph.get( v ) )&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;if( process.test( e ) )&#10;&#9;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;println( &quot;processed=&quot; + e );&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#10;&#9;&#9;}&#10;&#9;&#10;&#9;return result;&#10;}&#10;&#10;&#10; &#10;    &#10;    /*&#10;&#9;@Test&#10;&#9;void compute$One$Test()&#10;&#9;&#9;{&#10;&#9;&#9;&#10;&#9;&#9;//@formatter:off&#10;&#9;&#9;var graph_directed = Map.&lt;Integer,List&lt;Integer&gt;&gt;of( 1, List.&lt;Integer&gt;of( 2, 3 ),&#10;&#9;&#9;                                                    2, List.&lt;Integer&gt;of( 3, 4 ),&#10;&#9;&#9;                                                    3, List.&lt;Integer&gt;of( 4 ),&#10;&#9;&#9;                                                    4, List.&lt;Integer&gt;of() );&#10;&#9;&#9;var graph_unconnected  = Map.&lt;Integer,List&lt;Integer&gt;&gt;of( 1, List.&lt;Integer&gt;of( 3, 5 ),&#10;                                                    2, List.&lt;Integer&gt;of( 4 ),&#10;                                                    3, List.&lt;Integer&gt;of( 5 ),&#10;                                                    4, List.&lt;Integer&gt;of(),&#10;                                                        5, List.&lt;Integer&gt;of( 7,9 ),&#10;                                                        6, List.&lt;Integer&gt;of( 8,10),&#10;                                                        7, List.&lt;Integer&gt;of(),&#10;                                                        8, List.&lt;Integer&gt;of(  ),&#10;                                                        9, List.&lt;Integer&gt;of(  ),&#10;                                                        10, List.&lt;Integer&gt;of() );&#10;&#9;&#9;//@formatter:on&#10;&#9;&#9;&#10;&#9;&#9;System.out.println( &quot;BreadthFirstSearchTest computeOneTest &quot; + $One$( graph_directed ) );&#10;&#9;&#9;&#10;&#9;&#9;}&#10;    */" description="BFS breadth first search" toReformat="false" toShortenFQNames="true">
    <variable name="One" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="method graph algo DFS" value="&#10;public static final Set&lt;Integer&gt; $One$( Map&lt;Integer,List&lt;Integer&gt;&gt; graph,&#10;&#9;                                      Integer startVertex,&#10;&#9;&#9;                                              Consumer&lt;Integer&gt; work )&#10;{&#10;&#9;if( graph.size() &lt; 2 )&#10;&#9;&#9;{&#10;&#9;&#9;logAtWarning( &quot;distance: string param must not ne null or empty&quot; );&#10;&#9;&#9;return Set.&lt;Integer&gt;of();&#10;&#9;&#9;}&#10;&#9;&#10;&#9;var s         = new ArrayDeque&lt;Integer&gt;();&#10;&#9;var processed = new HashSet&lt;Integer&gt;();&#10;&#9;var start_vertex = ( startVertex == null ) ? graph.keySet()&#10;&#9;                                                  .iterator()&#10;&#9;                                                  .next() : startVertex;&#10;&#9;Consumer&lt;Integer&gt; work_ = ( work == null ) ? x -&gt;&#10;&#9;{&#10;&#9;} : work;&#10;&#9;&#10;&#9;Predicate&lt;Integer&gt; is_process = ( vertex ) -&gt;&#10;&#9;{&#10;&#9;if( processed.contains( vertex ) )&#10;&#9;&#9;return false;&#10;&#9;processed.add( vertex );&#10;&#9;return true;&#10;&#9;};&#10;&#9;&#10;&#9;Consumer&lt;Integer&gt; will_process = s::addFirst;&#10;&#9;&#10;&#9;System.out.println( String.format( &quot;start from : %s &quot;, start_vertex ) );&#10;&#9;will_process.accept( start_vertex );&#10;&#9;while( !s.isEmpty() )&#10;&#9;&#9;{&#10;&#9;&#9;var v = s.pollLast();&#10;&#9;&#9;if( is_process.test( v ) )&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;for( var e : graph.get( v ) )&#10;&#9;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;will_process.accept( e );&#10;&#9;&#9;&#9;&#9;//System.out.println( String.format( &quot;      v=%s e=%s&quot;, v, e ) );&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;System.out.println( String.format( &quot;processed : %s &quot;, v ) );&#10;&#9;&#9;&#9;work_.accept( v );&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;return processed;&#10;}&#10;&#10;&#10; &#10;    &#10;    /*&#10;&#9;@Test&#10;&#9;void $One$Test()&#10;&#9;&#9;{&#10;&#9;&#9;&#10;&#9;&#9;//@formatter:off&#10;&#9;&#9;var graph_directed = Map.&lt;Integer,List&lt;Integer&gt;&gt;of( 1, List.&lt;Integer&gt;of( 2, 3 ),&#10;&#9;&#9;                                                    2, List.&lt;Integer&gt;of( 3, 4 ),&#10;&#9;&#9;                                                    3, List.&lt;Integer&gt;of( 4 ),&#10;&#9;&#9;                                                    4, List.&lt;Integer&gt;of() );&#10;&#9;&#9;var graph_unconnected  = Map.&lt;Integer,List&lt;Integer&gt;&gt;of( 1, List.&lt;Integer&gt;of( 3, 5 ),&#10;                                                    2, List.&lt;Integer&gt;of( 4 ),&#10;                                                    3, List.&lt;Integer&gt;of( 5 ),&#10;                                                    4, List.&lt;Integer&gt;of(),&#10;                                                        5, List.&lt;Integer&gt;of( 7,9 ),&#10;                                                        6, List.&lt;Integer&gt;of( 8,10),&#10;                                                        7, List.&lt;Integer&gt;of(),&#10;                                                        8, List.&lt;Integer&gt;of(  ),&#10;                                                        9, List.&lt;Integer&gt;of(  ),&#10;                                                        10, List.&lt;Integer&gt;of() );&#10;&#9;&#9;//@formatter:on&#10;&#9;&#9;&#10;&#9;&#9;System.out.println( &quot;BreadthFirstSearchTest computeOneTest &quot; + $One$( graph_directed,null,null ) );&#10;&#9;&#9;&#10;&#9;&#9;}&#10;    */" description="DFS depth first search" toReformat="false" toShortenFQNames="true">
    <variable name="One" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="method graph algo TS" value="public static final List&lt;Integer&gt; $sort$( Map&lt;Integer,List&lt;Integer&gt;&gt; graph )&#10;{&#10;&#9;if( graph.size() &lt; 2 )&#10;&#9;&#9;{&#10;&#9;&#9;logAtWarning( &quot;distance: string param must not ne null or empty&quot; );&#10;&#9;&#9;return List.&lt;Integer&gt;of();&#10;&#9;&#9;}&#10;&#9;&#10;&#9;var s            = new ArrayDeque&lt;Integer&gt;();&#10;&#9;var processed    = new HashSet&lt;Integer&gt;();&#10;&#9;var inputs       = new HashMap&lt;Integer,Integer&gt;();&#10;&#9;var result       = new ArrayList&lt;Integer&gt;();&#10;&#9;var start_vertex = 1;&#10;&#9;&#10;&#9;for( var i : graph.keySet() )&#10;&#9;&#9;{&#10;&#9;&#9;inputs.put( i, 0 );&#10;&#9;&#9;}&#10;&#9;&#10;&#9;for( var i : graph.keySet() )&#10;&#9;&#9;{&#10;&#9;&#9;for( var j : graph.get( i ) )&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;inputs.compute( j, ( k, v ) -&gt; v + 1 );&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;var min_=   Collections.min(inputs.values()); //if graph has cycles&#10;&#9;inputs.replaceAll( ( k, w ) -&gt; w - min_ );&#10;&#10;&#9;var l1 = inputs.entrySet()&#10;               .stream()&#10;               .filter( e -&gt; e.getValue() &lt;= 0 )&#10;               .map( Map.Entry::getKey )&#10;               .collect( toList() );&#10;&#9;s.addAll( l1 );&#10;&#9;&#10;&#9;System.out.println( String.format( &quot;start from : %s &quot;, s ) );&#10;&#9;while( !s.isEmpty() )&#10;&#9;&#9;{&#10;&#9;&#9;var v = s.pollLast();&#10;&#9;&#9;&#10;&#9;&#9;for( var e : graph.get( v ) )&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;inputs.compute( e, ( k, w ) -&gt; w - 1 );&#10;&#9;&#9;&#9;if( inputs.get( e ) == 0 ) // ==0 important&#10;&#9;&#9;&#9;&#9;s.add( e );&#10;&#9;&#9;&#9;}&#10;&#9;&#9;System.out.println( String.format( &quot;processed : %s &quot;, v ) );&#10;&#9;&#9;result.add( v );&#10;&#9;&#9;}&#10;&#9;&#10;&#9;return result;&#10;}&#10;&#9;&#9;&#10;&#9;/*&#10;&#9;* &#9;@Test&#10;&#9;void $sort$Test()&#10;&#9;&#9;{&#10;&#9;&#9;&#10;&#9;&#9;//@formatter:off&#10;&#9;&#9;var graph_directed = Map.&lt;Integer,List&lt;Integer&gt;&gt;of( 2, List.&lt;Integer&gt;of( 3, 4 ),&#10;&#9;&#9;                                                    3, List.&lt;Integer&gt;of( 4 ),&#10;&#9;&#9;                                                    4, List.&lt;Integer&gt;of(),&#10;&#9;&#9;                                                    1, List.&lt;Integer&gt;of( 2, 3 ) );&#10;&#9;&#9;&#10;&#9;&#9;&#10;&#9;&#9;var graph_unconnected  = Map.&lt;Integer,List&lt;Integer&gt;&gt;of( 1, List.&lt;Integer&gt;of( 3, 5 ),&#10;&#9;&#9;                                                        2, List.&lt;Integer&gt;of( 4 ),&#10;&#9;&#9;                                                        3, List.&lt;Integer&gt;of( 5 ),&#10;&#9;&#9;                                                        4, List.&lt;Integer&gt;of(),&#10;&#9;&#9;                                                        5, List.&lt;Integer&gt;of( 7,9 ),&#10;&#9;&#9;                                                        6, List.&lt;Integer&gt;of( 8,10),&#10;&#9;&#9;                                                        7, List.&lt;Integer&gt;of(),&#10;&#9;&#9;                                                        8, List.&lt;Integer&gt;of(  ),&#10;&#9;&#9;                                                        9, List.&lt;Integer&gt;of(  ),&#10;&#9;&#9;                                                        10, List.&lt;Integer&gt;of() );&#10;&#9;&#9;//@formatter:on&#10;&#9;&#9;&#10;&#9;&#9;System.out.println( &quot;BreadthFirstSearchTest computeOneTest &quot; + $sort$( graph_directed ) );&#10;&#9;&#9;&#10;&#9;&#9;}&#10;&#9;* */" description="TS topological sort" toReformat="false" toShortenFQNames="true">
    <variable name="sort" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="func convert int to float" value="Integer.valueOf( (int) i._1 )&#10;       .floatValue()" description="Integer.valueOf.floatValue" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="func округление" value="Math.round () //данный метод округляет до ближайшего целого числа.&#10;Math.round (*10)/10 //округление до 0,1&#10;Math.floor () // данный метод округляет число до ближайшего целого вниз.&#10;Math.ceil()   //данный метод округляет число до ближайшего целого вверх.&#10;trunc //целая часть числа &#10;fruc //дробная часть числа" description="method" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="for WHILE POP + С-STYLE" value="var q   = new ArrayDeque&lt;Integer&gt;( $arr$ );&#10;var result = new ArrayList&lt;Integer&gt;();&#10;Integer e=null;&#10;while( (e=q.pollLast())!=null )&#10;&#9;{&#10;&#9;var fst = q.peekFirst();&#10;&#9;var lst = q.peekLast();&#10;&#9;result.add( 0, e );&#10;&#9;}&#10;print( result );$END$&#10;&#9;&#9;&#9;" description="while poolLast" toReformat="false" toShortenFQNames="true">
    <variable name="arr" expression="iterableVariable()" defaultValue="arr" alwaysStopAt="true" />
    <context>
      <option name="JAVA_EXPRESSION" value="true" />
      <option name="JAVA_STATEMENT" value="true" />
    </context>
  </template>
</templateSet>