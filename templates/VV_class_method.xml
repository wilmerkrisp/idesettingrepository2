<templateSet group="VV_class_method">
  <template name="method private" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/* private method&#10;&#9;&#10;- covariance: this overrided method can return subclass unstead class:&#10;      resultSomeSuperclass f_method()&#10;      resultSomeSubclass   f_overrided_method()&#10;&#10;&#10;&#10;public privateFinal protectedPackage _package_ final &#10;throws Exception, VX_myxception &#10;@Override  &#10;*/&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;private  void    threeCompute_(String string)&#10;{&#10;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*&#10;throw new VX_exception( &quot;vError&quot; );&#10;log_.debug   ( &quot;${PROJECT_NAME} ${PACKAGE_NAME} ${NAME}  f_test: &quot; ); &#10;&#10;use assertions for situations that can never occur&#10;assert false:&quot;Assert message&quot;;&#10; &#10; */&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;///assert string==null: &quot;Argument should not be null.&quot; ;&#10;assert string!= null &amp;&amp; !string.isBlank() : &quot;Argument should not be empty.&quot; );&#10;&#10;&#10;&#10;&#10;return ;&#10;} " description="private method for mutable and immutable calsses" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="OLDmethod argument vararg" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*&#10; &#10; * example 1&#10; *&#10; *              v_obj.f_method(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;);&#10; *&#10; *&#10; * example 2&#10; *&#10; *              pass array instead vararg&#10; *              v_obj.f_method(new String[]{ new String(&quot;1&quot;), new String(&quot;2&quot;), new String(&quot;3&quot;) });&#10; *&#10; * example 3&#10; *&#10; *           - covariance: this overrided method can return subclass unstead class:&#10; *                  resultSomeSuperclass f_method()&#10; *                  resultSomeSubclass   f_overrided_method()&#10;&#10;public privateFinal protectedPackage _package_ final &#10;throws Exception, VX_myxception &#10;@Override  &#10; */&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;/**                         &#10; *      method&#10; *      !CHANGE_ME_DESCRIPTION!&#10; * &#10; * &lt;pre&gt;{@code&#10; *&#10; * &#10;&#10; *&#10; * &#10; * &#10; * }&lt;/pre&gt; ПОМНИ СГЕНЕРИТЬ JAVADOC MAC8+fixDocComment И УБРАТЬ ЭТОТ ТЕКСТ&#10; */&#10;&#10;public  void    f_method(@NotNull final String ... parameter)             &#10;{&#10;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*&#10;get input atguments from p_1 array&#10;super.f_method(p_1); &#10;&#10;for( String v_a : p_1 )&#10;&#9;{&#10;&#9;log_.debug( &quot;$class$ $method$ inputArg: &quot; + v_a );&#10;&#9;} &#10; &#10;&#10;  (*) для mutable objects and NEW-SET-CALL pattern:&#10;        свойство в конструкторе не проверяем -&gt; проверяем в итоговом вызове метода&#10;        в сетере даем возможность обнулить параметр  -&gt; потом в методе для него выставим дефолтное значение&#10;        if (stringTwo==null) log_.info( &quot;Input parameter is null.&quot; );&#10; &#10;  (*) для immutable objects and NEW-CALL pattern:&#10;        (1)свойство в конструкторе проверяем  -&gt; в итоговом вызове НЕ проверяем&#10;        Objects.requireNonNull( object.stringTwo );&#10;&#10;&#10;  (*) для param receive strategy:&#10;        (1) Objects.requireNonNull(p_1);&#10;        (2) String p_2= (p_1 == null)? new String() : p_1;&#10;&#10; &#10;  &#9;(*)use assertions to check method parameters of private methods&#10; &#9;        - use assertions for situations that can never occur&#10;&#9;&#9;- assert false:&quot;Assert message&quot;;&#10; */&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;checkNotNull( parameter,&quot;Nullable argument&quot; );&#10;checkArgument( !parameter.isEmpty(),&quot;Empty argument&quot; );&#10;&#10;checkArgument(!Arrays.stream( parameter ).anyMatch( x-&gt;x.isEmpty() ),&quot;Empty element&quot;);&#10;checkArgument(!Arrays.stream( parameter ).anyMatch( x-&gt;x==null ),&quot;Nullable element&quot;);&#10;&#10;$END$&#10;&#10;&#10;&#10;&#10;&#10;return;&#10;} " description="method wuth variableLenght parameters" toReformat="false" toShortenFQNames="true">
    <variable name="class" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="method" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="OLD method1 handle exception" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*&#10;public privateFinal protectedPackage _package_ final&#10;throws Exception, VX_myxception &#10;@Override  &#10; &#10; &#10; */&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;/**                         method f_method  try-catch&#10; * &#10; *      !CHANGE_ME_DESCRIPTION!&#10; * &#10; * &lt;pre&gt;{@code&#10; *&#10; * &#10; * example 1&#10; * &#10; *           v_obj.f_method(&quot;test&quot;);&#10; *&#10; * example 2&#10; *&#10; *           - covariance: this overrided method can return subclass unstead class:&#10; *                  resultSomeSuperclass f_method()&#10; *                  resultSomeSubclass   f_overrided_method()&#10; * &#10; *&#10; * }&lt;/pre&gt; ПОМНИ СГЕНЕРИТЬ JAVADOC MAC8+fixDocComment И УБРАТЬ ЭТОТ ТЕКСТ&#10; */&#10;&#10;public void f_method(@NotNull final String parameter)                      &#10;&#9;{&#10;&#9;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;&#9;/*&#10;&#9;super.f_method(p_1);&#10;&#10;&#10;        catch NO ALL EXCEPTIONS only that I can RESOLVE HERE&#10;        catch (final 1Exception | 2Exception  p_exception) &#9; &#10;&#9; &#10;&#9;throw new VX_exception( &quot;vError&quot; );&#10;&#9;log_.debug   (&quot;$class$ f_method: &quot;+p_1);&#10;&#9;&#10;&#9;&#10;          (*) для mutable objects and NEW-SET-CALL pattern:&#10;                в сетере даем возможность обнулить параметр  -&gt; потом в методе для него выставим дефолтное значение&#10;                свойство в конструкторе не проверяем -&gt; проверяем в итоговом вызове метода&#10;                if (stringTwo==null) log_.info( &quot;Input parameter is null.&quot; );&#10;                &#10;          (*) для immutable objects and NEW-CALL pattern:&#10;                (1)свойство в конструкторе проверяем  -&gt; в итоговом вызове НЕ проверяем&#10;                Objects.requireNonNull( object.stringTwo );&#10;     &#10;     &#10;          (*) для param receive strategy:&#10;                (1) Objects.requireNonNull(p_1);&#10;&#9;        (2) String p_2= (p_1 == null)? new String() : p_1;&#10; &#10;  &#9;(*)use assertions to check method parameters of private methods&#10; &#9;        - use assertions for situations that can never occur&#10;&#9;&#9;- assert false:&quot;Assert message&quot;;&#10;                &#10;&#9; */&#10;&#9;//&lt;/editor-fold&gt;&#10;&#9;&#10;&#9;checkNotNull( parameter,&quot;Nullable argument&quot; );&#10;&#9;checkArgument( !parameter.isEmpty(),&quot;Empty argument&quot; );&#10;&#10;&#9;try&#10;&#9;&#9;{&#10;&#9;&#9;&#10;&#9;&#9;&#10;&#9;&#9;&#10;&#9;&#9;$SELECTION$&#10;&#9;&#9;$END$&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#10;&#9;&#9;}&#10;&#9;catch(final VX_exception p_exception )&#10;&#9;&#9;{&#10;&#9;&#9;log_.error(&quot;cause&quot;+p_exception, p_exception );&#10;&#9;&#9;&#10;&#9;&#9;// COMPENSATE BRUNCH  NEDD RESTORE SYSTEM HERE&#10;&#9;&#9;}&#10;&#9;&#10;&#9;} " description="class method  TRY CATCH / RESOLVExcptn STRATEGY4" toReformat="false" toShortenFQNames="true">
    <variable name="class" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="OLDmethod4" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*&#10; &#10;public privateFinal protectedPackage _package_ final&#10;throws Exception, VX_myxception &#10;@Override  &#10; &#10; */&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;/**                         method f_method   ( handle exception UP)&#10; * &#10; *      !CHANGE_ME_DESCRIPTION!&#10; * &#10; * &lt;pre&gt;{@code&#10; *&#10; * &#10; * example 1&#10; * &#10; *      try&#10; *              {&#10; *              v_obj.f_method( &quot;test&quot; );&#10; *              }&#10; *      catch(final Exception p_exception )&#10; *              {&#10; *              System.out.println(p_exception  );&#10; *              }&#10; *&#10; *&#10; * example 2&#10; *&#10; *           - covariance: this overrided method can return subclass unstead class:&#10; *                  resultSomeSuperclass f_method()&#10; *                  resultSomeSubclass   f_overrided_method()&#10; * &#10; *&#10; * &#10; * }&lt;/pre &gt;  ПОМНИ СГЕНЕРИТЬJAVADOC MAC8 +fixDocComment И УБРАТЬ ЭТОТ ТЕКСТ&#10; * */&#10;public void f_method(@NotNull final String p_1) throws Exception //,VX_myxception                   &#10;&#9;{&#10;&#9;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;&#9;/*&#10;&#9;log_.debug   (&quot;$class$ f_method: &quot;+p_1);&#10;&#9;throw new VX_exception( &quot;vError&quot; );&#10;&#9;super.f_method(p_1);&#10;&#9;&#9; &#10;&#9; &#10;          (*) для mutable objects and NEW-SET-CALL pattern:&#10;                свойство в конструкторе не проверяем -&gt; проверяем в итоговом вызове метода&#10;                в сетере даем возможность обнулить параметр  -&gt; потом в методе для него выставим дефолтное значение&#10;&#9;&#9; if (stringTwo==null) log_.info( &quot;Input parameter is null.&quot; );&#10;     &#10;          (*) для immutable objects and NEW-CALL pattern:&#10;                (1)свойство в конструкторе проверяем  -&gt; в итоговом вызове НЕ проверяем&#10;                Objects.requireNonNull( object.stringTwo );&#10;     &#10;     &#10;          (*) для param receive strategy:&#10;                (1) Objects.requireNonNull(p_1);&#10;&#9;            (2) String p_2= (p_1 == null)? new String() : p_1;&#10;              &#10; &#9;(*)use assertions to check method parameters of private methods&#10; &#9;        - use assertions for situations that can never occur&#10;&#9;&#9;- assert false:&quot;Assert message&quot;;&#10;&#9;&#9;&#9;        &#9; &#10;&#9; */&#10;&#9;//&lt;/editor-fold&gt;&#10;&#9;&#10;&#9;&#10;&#9;Objects.requireNonNull( p_1 );&#10;&#9;&#10;&#9;$END$&#10;&#9;&#9;&#10; &#9;&#10;&#9;return;&#10;&#9;} " description="class method  THROWS {DEPRECATED}" toReformat="false" toShortenFQNames="true">
    <variable name="class" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="OLDmethod argument &lt;?&gt;" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*&#10; * example 1&#10; *&#10; *              VC_gener&lt; Long &gt; v_obj1 = new VC_gener&lt;  &gt;( 12L );&#10; *              VC_gener&lt; String &gt; v_obj2 = new VC_gener&lt;  &gt;( 12L );&#10; *              v_.f_test_genericlass(v_obj2);&#10; *              v_.f_test_genericlass(v_obj1);&#10; *&#10; * example 2&#10; *&#10; *           - covariance: this overrided method can return subclass unstead class:&#10; *                  resultSomeSuperclass f_method()&#10; *                  resultSomeSubclass   f_overrided_method()&#10; *&#10; *&#10; * example 5&#10; *&#10; *               inside method create object of  T  type, like NEW  T (), based on the real input param type&#10; *                    T  v_output=( T ) p_input.getClass( ).getDeclaredConstructor( new Class[12] ).newInstance( );&#10; *&#10; * example 6&#10; *&#10; *               inside method create object of  T [] type, like NEW  T [12] , based on the real input param type&#10; *                    T [] v_arr = ( T []) java.lang.reflect.Array.newInstance( p_input.getClass().getComponentType( ), p_input.length );&#10; *&#10; *&#10; &#10;public privateFinal protectedPackage _package_ final&#10;throws Exception, VX_myxception &#10;@Override &#10; */&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;/**&#10; *      method test with argument of GENERIC&lt;anyclass&gt;&#10; *      !CHANGE_ME_DESCRIPTION!&#10; *      &#10; * &lt;pre&gt;{@code&#10; *&#10; * &#10;&#10; * &#10; * }&lt;/pre&gt;&#10; */&#10;&#10;public void fg_test_genericlass(@NotNull final $class$&lt; ? /* extends super VC_ &amp; VI_ *//* extends super VCG_&lt;String&gt; &amp; VIG_&lt;String&gt; */ &gt; parameter )                   &#10;&#9;{&#10;&#9;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;&#9;/*&#10;&#9;throw new VX_exception( &quot;vError&quot; );&#10;&#9;log_.debug   (&quot;$class$ f_method f_test_genericlass: &quot;+p_1);&#10;&#9;super.fg_test_genericlass(p_1);&#10;&#9;log_.debug( &quot;argument type: &quot; + (( p_1 instanceof VC_gener&lt;?&gt; ) ? &quot;VV_&quot; : &quot;no&quot;) );&#9; &#10;&#9;&#10;&#9;&#10;&#9; &#10;           (*) для mutable objects and NEW-SET-CALL pattern:&#10;                свойство в конструкторе не проверяем -&gt; проверяем в итоговом вызове метода&#10;                 в сетере даем возможность обнулить параметр  -&gt; потом в методе для него выставим дефолтное значение&#10;                  if (stringTwo==null) log_.info( &quot;Input parameter is null.&quot; );&#10;                   &#10;          (*) для immutable objects and NEW-CALL pattern:&#10;                (1)свойство в конструкторе проверяем  -&gt; в итоговом вызове НЕ проверяем&#10;                Objects.requireNonNull( object.stringTwo );&#10;     &#10;     &#10;          (*) для param receive strategy:&#10;                (1) Objects.requireNonNull(p_1);&#10;&#9;            (2) String p_2= (p_1 == null)? new String() : p_1;&#10; &#9; &#10; &#9;(*)use assertions to check method parameters of private methods&#10; &#9;        - use assertions for situations that can never occur&#10;&#9;&#9;- assert false:&quot;Assert message&quot;;&#10;&#10; &#9; &#10;&#9; */&#10;&#9;//&lt;/editor-fold&gt;&#10;&#9;&#10;&#9;checkNotNull( parameter,&quot;Nullable argument&quot; );&#10;&#9;checkArgument( !parameter.isEmpty(),&quot;Empty argument&quot; );&#10; &#10;&#9;p_1.f_test( );&#10;&#9;$END$&#10;&#9;&#9;&#10;&#9;&#9;&#10;&#9;//&#10;&#9;return;&#10;&#9;}&#10;" description="class method  argument of GENERIC&lt;anyclass&gt;" toReformat="false" toShortenFQNames="true">
    <variable name="class" expression="className()" defaultValue="" alwaysStopAt="false" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="method7" value="@Override&#10;final&#9;" description="class method OVERRIDE in subclass" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="OLDmethod2 rethrow" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*&#10;public privateFinal protectedPackage _package_ final&#10;throws Exception, VX_myxception &#10;@Override  &#10; &#10; &#10; */&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;/**                         method f_method  try-catch&#10; * &#10; *      !CHANGE_ME_DESCRIPTION!&#10; * &#10; * &lt;pre&gt;{@code&#10; *&#10; * &#10; * example 1&#10; * &#10; *           v_obj.f_method(&quot;test&quot;);&#10; *&#10; * example 2&#10; *&#10; *           - covariance: this overrided method can return subclass unstead class:&#10; *                  resultSomeSuperclass f_method()&#10; *                  resultSomeSubclass   f_overrided_method()&#10; * &#10; * example 3&#10; *           - stacktrace attached to new exception&#10; *           - for runtime exception you NO need  THROWS or NO need outer try-catch  block&#10; *              &#10; *&#10; * }&lt;/pre&gt; ПОМНИ СГЕНЕРИТЬ JAVADOC MAC8+fixDocComment И УБРАТЬ ЭТОТ ТЕКСТ&#10; */&#10;&#10;public void f_method(@NotNull final String parameter)                      &#10;&#9;{&#10;&#9;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;&#9;/*&#10;&#9;super.f_method(p_1);&#10;&#9;&#10;&#9;&#10;&#9;&#10;        CATCH ALL EXCEPTIONS &amp; RETHROW: checked &amp; unchecked&#10;        stacktrace attached to new exception&#10;        for runtime exception you NO need  THROWS or NO need outer try-catch  block&#10;        catch (final 1Exception | 2Exception  p_exception) &#9; &#10;&#9; &#10;&#9; &#10;&#9; &#10;          (*) для mutable objects and NEW-SET-CALL pattern:&#10;                свойство в конструкторе не проверяем -&gt; проверяем в итоговом вызове метода&#10;                в сетере даем возможность обнулить параметр  -&gt; потом в методе для него выставим дефолтное значение&#10;                 if (stringTwo==null) log_.info( &quot;Input parameter is null.&quot; );&#10;                 &#10;          (*) для immutable objects and NEW-CALL pattern:&#10;                (1)свойство в конструкторе проверяем  -&gt; в итоговом вызове НЕ проверяем&#10;                Objects.requireNonNull( object.stringTwo );&#10;     &#10;     &#10;          (*) для param receive strategy:&#10;                (1) Objects.requireNonNull(p_1);&#10;&#9;        (2) String p_2= (p_1 == null)? new String() : p_1;&#10; &#10;                &#10; &#9;(*)use assertions to check method parameters of private methods&#10; &#9;        - use assertions for situations that can never occur&#10;&#9;&#9;- assert false:&quot;Assert message&quot;;&#9;        &#10;&#9;        &#9; &#10;&#9; */&#10;&#9;//&lt;/editor-fold&gt;&#10;&#9;&#10;&#9;checkNotNull( parameter,&quot;Nullable argument&quot; );&#10;&#9;checkArgument( !parameter.isEmpty(),&quot;Empty argument&quot; );&#10;&#10;&#9;try&#10;&#9;&#9;{&#10; &#10;&#9;&#9;&#10;&#9;&#9;&#10;&#9;&#9;$SELECTION$&#10;&#9;&#9;$END$&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#10;&#9;&#9;}&#10;&#9;catch( final RuntimeException p_exception )&#10;&#9;&#9;{&#10;&#9;&#9;throw p_exception;&#10;&#9;&#9;}&#10;&#9;catch( final Exception p_exception )&#10;&#9;&#9;{&#10;&#9;&#9;throw new VX_box_exception( &quot; cause &quot; , p_exception );&#10;&#9;&#9;}&#10;&#9;&#10;&#9;} " description="class method  TRY CATCH / CHECKEDxcptn UP STRATEGY3" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="OLDmethod3 return optional" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*&#10; &#10;public privateFinal protectedPackage _package_ final&#10;throws Exception, VX_myxception &#10;@Override&#10; &#10; */&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;/**                         method f_method&#10; * &#10; *      !CHANGE_ME_DESCRIPTION!&#10; * &#10; * &lt;pre&gt;{@code&#10; *&#10; *  &#10; * example 1&#10; *            - Возвращает опциональный тип, который может быть пустым, в случае провала метода&#10; *            - НЕ генерирую runtime ошибки выполнения метода&#10; *&#10; *&#10; * &#10; * example 1&#10; * &#10; *           ?Person personNew = person.orElse(new Person());&#10; *           ?v_obj.f_method(&quot;test&quot;);&#10; *&#10; * example 2&#10; *&#10; *           - covariance: this overrided method can return subclass unstead class:&#10; *                  resultSomeSuperclass f_method()&#10; *                  resultSomeSubclass   f_overrided_method()&#10; *&#10; * &#10; * }&lt;/pre&gt; ПОМНИ СГЕНЕРИТЬ JAVADOC MAC8+fixDocComment И УБРАТЬ ЭТОТ ТЕКСТ&#10; */&#10; &#10;public Optional&lt;$String$&gt; $f_method$(@NotNull final $String$ peremeter)                    &#10;&#9;{&#10;&#9;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;&#9;/*&#10;&#9;log_.debug   (&quot;$class$ f_method: &quot;+p_1);&#10;&#9;super.f_method(p_1);&#10;&#9; &#10;&#9;Возвращает опциональный тип, который может быть пустым, в случае провала метода&#10;&#9;&#10;&#9;&#10;&#9;&#10;          (*) для mutable objects and NEW-SET-CALL pattern:&#10;                свойство в конструкторе не проверяем -&gt; проверяем в итоговом вызове метода&#10;                 в сетере даем возможность обнулить параметр  -&gt; потом в методе для него выставим дефолтное значение&#10;                if (stringTwo==null) log_.info( &quot;Input parameter is null.&quot; );&#10;    &#10;          (*) для immutable objects and NEW-CALL pattern:&#10;                (1)свойство в конструкторе проверяем  -&gt; в итоговом вызове НЕ проверяем&#10;                Objects.requireNonNull( object.stringTwo );&#10;     &#10;     &#10;          (*) для param receive strategy:&#10;                (1) Objects.requireNonNull(p_1);&#10;&#9;            (2) String p_2= (p_1 == null)? new String() : p_1;&#10;              &#10; &#9;(*)use assertions to check method parameters of private methods&#10; &#9;        - use assertions for situations that can never occur&#10;&#9;&#9;- assert false:&quot;Assert message&quot;;&#9;        &#10;&#9;        &#9;&#10;&#9;*/&#10;&#9;//&lt;/editor-fold&gt;&#10;&#9;&#10;&#9;&#10;&#9;checkNotNull( parameter,&quot;Nullable argument&quot; );&#10;&#9;checkArgument( !parameter.isEmpty(),&quot;Empty argument&quot; );&#10;&#9;&#10;&#9;$END$&#10;&#9;&#10;&#9;return Optional.ofNullable( p_1 );&#10;&#9;} " description="class method /OPTIONAL STRATEGY2" toReformat="false" toShortenFQNames="true">
    <variable name="f_method" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="String" expression="classNameComplete()" defaultValue="" alwaysStopAt="true" />
    <variable name="class" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="method public mutable" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/* public method&#10;&#10;&#10;&#10; *  1) no method args, because all inside props&#10; *  &#10; *  2) количество параметров должно быть не более 4-х, иначе:&#10; *   &#9;- разбить метод на несколько (как например в NEW-SET-CALL для каждого параметра отдельный сетер)&#10; *   &#9;- вынести группу параметров в value-класс (nested static) (helper class)&#10; *   &#9;- все параметры зашить в паттерн билдер, где параметры можно присваивать по-очереди (так что билдер применим и на мутабельном объекте)&#10; *  &#10;&#10;&#10;&#9;0) перегенерировать javadoc MAC8+fixDocComment&#10;&#10;- covariance: this overrided method can return subclass unstead class:&#10;       resultSomeSuperclass f_method()&#10;       resultSomeSubclass   f_overrided_method()&#10;&#10;@throws NullPointerException if argument nullable&#10;&#10;public privateFinal protectedPackage _package_ final &#10;throws Exception, VX_myxception &#10;@Override  &#10;*/&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;/**&lt;pre&gt;&#10; *   compute method&#10; *      - not for inheritance&#10;&#9;&#10; *&#10; * {@code&#10; * &#10; *          &#10; *&#10; * }&#10; * &lt;/pre&gt;&#10; * &#10;&#10; *       &#10; *      @throws IllegalStateException if some object's property null or empty&#10; *      @return empty value if input argument empty  &#10; */&#10;public final Optional&lt;String&gt;    $f_method$(String string)&#10;&#9;{&#10;&#9;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;&#9;/*&#10;&#9;throw new VX_exception( &quot;vError&quot; );&#10;&#9;log_.debug   ( &quot;${PROJECT_NAME} ${PACKAGE_NAME} ${NAME}  f_test: &quot; );&#10;&#9;super.f_method(p_1);&#10;&#9;&#10;&#9;/генерирую runtime ошибки программирования &#10;&#9;throw new IllegalArgumentException(  );&#10;&#9;&#10;&#9;генерирую runtime ошибки выполнения метода &#10;&#9;throw new MyApplicationException( &quot;vError&quot; );&#10;&#9;throw new NoResult$f_method$Exception( &quot;vError&quot; );&#10;&#9;&#10;&#9;&#10;&#9;&#10;&#9;- pattern new-set-call for mutable objects:&#10;&#9;- check integrity of object inside call methods&#10;&#9;&#9;throw new IllegalStateException( item1+item2 ); &#10;&#9; &#10;&#9;&#10;&#9;  (*) для mutable objects and NEW-SET-CALL pattern:&#10;&#9;        свойство в конструкторе не проверяем -&gt; проверяем в итоговом вызове метода&#10;&#9;        в сетере даем возможность обнулить параметр  -&gt; потом в методе для него выставим дефолтное значение&#10;&#9;&#9; if (stringTwo==null) log_.info( &quot;Input parameter is null.&quot; );&#10;&#9;  &#10;&#9;  (*) для param receive strategy:&#10;&#9;        (1) Objects.requireNonNull(p_1);&#10;&#9;        (2) String p_2= (p_1 == null)? new String() : p_1;&#10;&#9;&#10;&#9;три варианта проверки входного аргумента&#10;&#9;&#9; 1) @NonNull   от LOMBOK&#10;&#9;&#9; 2) notBlank(string) notEmpty(collection)&#10;&#9;&#9; 3) optional        &#10;&#9;&#10;&#9; */&#10;&#9;//&lt;/editor-fold&gt;&#10;&#9;&#10;&#9;if( string == null || string.isBlank() || !isConsistent() )&#10;&#9;&#9;{&#10;&#9;&#9;logAtWarning_( &quot;$f_method$: string param must not ne null or empty&quot; );&#10;&#9;&#9;return Optional.empty();&#10;&#9;&#9;}&#10;&#9;&#10;&#9;log_( &quot;$f_method$({})&quot;,string );&#10;&#9;&#10;&#9;return Optional.ofNullable( string );&#10;&#9;// todo postcondition check of output result&#10;&#9;} " description="for mutable classes" toReformat="false" toShortenFQNames="true">
    <variable name="f_method" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="OLDmethod argument lambda" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*&#10; &#10; * example 1&#10; *            - генерирую runtime ошибки программирования&#10; *            - генерирую runtime ошибки выполнения метода, если метод не вернет то что должен&#10; *&#10; *&#10; * example 2&#10; *&#10; *           v_obj.f_method(&quot;test&quot;);&#10; *&#10; * example 3&#10; *&#10; *           - covariance: this overrided method can return subclass unstead class:&#10; *                  resultSomeSuperclass f_method()&#10; *                  resultSomeSubclass   f_overrided_method()&#10; *                  &#10; &#10; &#10;public privateFinal protectedPackage _package_ final&#10;throws Exception, VX_myxception &#10;@Override &#10; */&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;/**&#10; *      method f_method&#10; *      !CHANGE_ME_DESCRIPTION!&#10; * &#10; * &lt;pre&gt;{@code&#10; *&#10; *&#10;&#10; *&#10; * &#10; * }&lt;/pre&gt; ПОМНИ СГЕНЕРИТЬ JAVADOC MAC8+fixDocComment И УБРАТЬ ЭТОТ ТЕКСТ&#10; */&#10;&#10;public void $f_method$(@NotNull final $String$ parameter)                    &#10;&#9;{&#10;&#9;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;&#9;/*&#10;&#9;log_.debug   (&quot;$class$ f_method: &quot;+p_1);&#10;&#9;super.f_method(p_1);&#10;&#10;&#9;генерирую runtime ошибки программирования &#10;&#9;&#9;throw new IllegalArgumentException(  );&#10;&#10;&#9;генерирую runtime ошибки выполнения метода &#10;&#9;&#9;throw new MyApplicationException( &quot;vError&quot; );&#10;&#9;&#9;throw new NoResult$f_method$Exception( &quot;vError&quot; );&#9; &#10;&#10;          (*) для mutable objects and NEW-SET-CALL pattern:&#10;                свойство в конструкторе не проверяем -&gt; проверяем в итоговом вызове метода&#10;                в сетере даем возможность обнулить параметр  -&gt; потом в методе для него выставим дефолтное значение&#10;&#9;&#9; if (stringTwo==null) log_.info( &quot;Input parameter is null.&quot; );&#10;     &#10;          (*) для immutable objects and NEW-CALL pattern:&#10;                (1)свойство в конструкторе проверяем  -&gt; в итоговом вызове НЕ проверяем&#10;                Objects.requireNonNull( object.stringTwo );&#10;     &#10;     &#10;          (*) для param receive strategy:&#10;                (1) Objects.requireNonNull(p_1);&#10;&#9;        (2) String p_2= (p_1 == null)? new String() : p_1;&#10; &#9;&#10; &#9;&#10; &#9;  (*)use assertions to check method parameters of private methods&#10; &#9;        - use assertions for situations that can never occur&#10;&#9;&#9;- assert false:&quot;Assert message&quot;;&#10;&#9; */&#10;&#9;//&lt;/editor-fold&gt;&#10;&#9;&#10;&#9;&#10;&#9;checkNotNull( parameter,&quot;Nullable argument&quot; );&#10;&#9;checkArgument( !parameter.isEmpty(),&quot;Empty argument&quot; );&#10;&#9;&#10;&#9;&#10;&#9;&#10;&#9;$END$&#10;&#9;&#9;&#10;&#9;&#9;&#10;&#9;//&#9;&#10;&#9;return;&#10;&#9;} " description="class method argument of LAMBDA type" toReformat="false" toShortenFQNames="true">
    <variable name="f_method" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="String" expression="classNameComplete()" defaultValue="" alwaysStopAt="true" />
    <variable name="class" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="OLDmethod argument collection" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*&#10; &#10; *&#10; * example 1&#10; *&#10; *              v_obj.f_method(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;);&#10; *&#10; *&#10; * example 2&#10; *&#10; *              pass array instead vararg&#10; *              v_obj.f_method(new String[]{ new String(&quot;1&quot;), new String(&quot;2&quot;), new String(&quot;3&quot;) });&#10; *&#10; * example 3&#10; *&#10; *           - covariance: this overrided method can return subclass unstead class:&#10; *                  resultSomeSuperclass f_method()&#10; *                  resultSomeSubclass   f_overrided_method()&#10; &#10; &#10;public privateFinal protectedPackage _package_ final &#10;throws Exception, VX_myxception &#10;@Override &#10;      &#10; */&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;/**     &#10; *      method f_method&#10; *      !CHANGE_ME_DESCRIPTION!&#10; * &#10; *  &lt;pre&gt;{@code&#10; *&#10;&#10; *&#10; * &#10; * &#10; * }&lt;/pre&gt; ПОМНИ СГЕНЕРИТЬ JAVADOC MAC8+fixDocComment И УБРАТЬ ЭТОТ ТЕКСТ&#10; */&#10;&#10;public  void    f_method(@NotNull final String ... parameter)             &#10;{&#10;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*&#10;get input atguments from p_1 array&#10;super.f_method(p_1);&#10; &#10; for( String v_a : p_1 )&#10;&#9;{&#10;&#9;log_.debug( &quot;$class$ $method$ inputArg: &quot; + v_a );&#10;&#9;}&#10; &#10; &#10;   (*) для mutable objects and NEW-SET-CALL pattern:&#10;        свойство в конструкторе не проверяем -&gt; проверяем в итоговом вызове метода&#10;         в сетере даем возможность обнулить параметр  -&gt; потом в методе для него выставим дефолтное значение&#10;&#9; if (stringTwo==null) log_.info( &quot;Input parameter is null.&quot; );&#10;&#9; &#10;  (*) для immutable objects and NEW-CALL pattern:&#10;        (1)свойство в конструкторе проверяем  -&gt; в итоговом вызове НЕ проверяем&#10;        Objects.requireNonNull( object.stringTwo );&#10;&#10;&#10;  (*) для param receive strategy:&#10;        (1) Objects.requireNonNull(p_1);&#10;        (2) String p_2= (p_1 == null)? new String() : p_1;&#10; &#10; &#10; &#9;(*)use assertions to check method parameters of private methods&#10; &#9;        - use assertions for situations that can never occur&#10;&#9;&#9;- assert false:&quot;Assert message&quot;; &#10; &#10; */&#10;//&lt;/editor-fold&gt;&#10;&#10;checkNotNull( parameter,&quot;Nullable argument&quot; );&#10;checkArgument( !parameter.isEmpty(),&quot;Empty argument&quot; );&#10;&#10;$END$&#10;&#10;&#9;&#10;return;&#10;} " description="method wuth Collection parameters" toReformat="false" toShortenFQNames="true">
    <variable name="class" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="method" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="OLDmethod argument &lt;E&gt; ANYTYPE" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*&#10; &#10; *&#10; * example 1&#10; *&#10; *           v_obj.f_testanyarg(&quot;stroka&quot;);&#10; *           v_obj.f_testanyarg(12);&#10; *&#10; * example 2&#10; *&#10; *           - covariance: this overrided method can return subclass unstead class:&#10; *                  resultSomeSuperclass f_method()&#10; *                  resultSomeSubclass   f_overrided_method()&#10; &#10;   пример 3&#10;            при использовании T... или T[] укомендуется добавлять аннотацию @SafeVarargs&#10; &#10; &#10;public privateFinal protectedPackage _package_ final &#10;throws Exception, VX_myxception &#10;@Override &#10;&#10; */&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;/**&#10; *                              method test with argument of ANYTYPE&#10; *      !CHANGE_ME_DESCRIPTION!&#10; * &#10; * &lt;pre&gt;{@code&#10; *&#10;&#10; * &#10; * &#10; *&#10; * }&lt;/pre&gt;&#10; */&#10;&#10;public &lt; E   /* extends super VC_ &amp; VI_ */ /* extends super VCG_&lt;?&gt; &amp; VIG_&lt;?&gt; */ /* extends super VCG_&lt; E &gt; &amp; VIG_&lt; E &gt; */ /* extends super VCG_&lt;String&gt; &amp; VIG_&lt;String&gt; */ &gt;void fg_testanyarg(@NotNull final  E  parameter )                    &#10;&#9;{&#10;&#9;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;&#9;/*&#10;&#9;throw new VX_exception( &quot;vError&quot; );&#10;&#9;super.fg_testanyarg(p_1);&#10;&#9;log_.debug( &quot;argument type: &quot; + (( p_1 instanceof VV_ ) ? &quot;VV_&quot; : &quot;no&quot;) );&#10;&#9;log_.debug( &quot;$class$  f_testanyarg: &quot;+p_1 );&#10;&#9;!NO new  E ()&#9; &#10;&#9; &#10;&#9; &#10;           (*) для mutable objects and NEW-SET-CALL pattern:&#10;                свойство в конструкторе не проверяем -&gt; проверяем в итоговом вызове метода&#10;                 в сетере даем возможность обнулить параметр  -&gt; потом в методе для него выставим дефолтное значение&#10;                if (stringTwo==null) log_.info( &quot;Input parameter is null.&quot; );&#10;     &#10;          (*) для immutable objects and NEW-CALL pattern:&#10;                (1)свойство в конструкторе проверяем  -&gt; в итоговом вызове НЕ проверяем&#10;                Objects.requireNonNull( object.stringTwo );&#10;     &#10;     &#10;          (*) для param receive strategy:&#10;                (1) Objects.requireNonNull(p_1);&#10;&#9;        (2) String p_2= (p_1 == null)? new String() : p_1;&#10; &#9; &#10; &#9;  &#10; &#9;  &#10; &#9;  (*)use assertions to check method parameters of private methods&#10; &#9;        - use assertions for situations that can never occur&#10;&#9;&#9;- assert false:&quot;Assert message&quot;;&#10; &#9; &#10;&#9; */&#10;&#9;//&lt;/editor-fold&gt;&#10;&#9;&#10;&#9;&#10;&#9;checkNotNull( parameter,&quot;Nullable argument&quot; );&#10;&#9;checkArgument( !parameter.isEmpty(),&quot;Empty argument&quot; );&#10;&#9;&#10;&#9;&#10;&#9;$END$&#10;&#9;&#9;&#10;&#9;&#9;&#10;&#9;//&#10;&#9;return;&#10;&#9;}&#10;" description="class method argument of ANYTYPE" toReformat="false" toShortenFQNames="true">
    <variable name="class" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="OLDmethod_clone" value="Deprecated &#10;use copy constructor instead&#9;" description="class method clone" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="OLDmethod_equals" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/* equals and hashCode&#10;&#10;-   НЕЛЬЗЯ переопределять данный метод для МУТАБЕЛЬНЫХ классов основываясь на равенстве всех свойств&#10;        - тк как только одно из свойств изменится то равенство сразу потеряется&#10;        - также объект потеряется сразу в хэш таблицах тк хэш объекта изменится&#10;&#10;-   для мутабельных классов следует переопределять данный метод отталкиваясь от равенства идентификатора выбранного для определения идентичности&#10;        - рекомендуется убедиться что hashcode возвращает точно то же самое значение независимо от любых изменений сделанных с объектом&#10;&#10;-   рекомендуется делать метод final, если будет сраниваться идентификатор выбранный для идентичности&#10;-   или (если не final) при наследовании следует вызывать super.equals  &#10;&#10;-   Если класс реализует интерфейс, который уточняет соглашения для метода equals, то в качестве типа указывайте этот интерфейс, что позволит выполнять сравнение классов, реализующих этот интерфейс. &#10;&#9;- вы должны получать доступ к значимым полям аргумента, используя методы самого интерфейса. &#10;&#9;- Если же тип аргумента определен как класс, то, в зависимости от условий, вам, возможно, удастся получить прямой доступ к полям аргумента&#10;&#10;-  фундаментальная проблема эквивалентных отношений в объектно ориентированных языках. &#10;&#9;Не существует способа расширить класс, порождающий экземпляры, и добавить к нему компонент значения, сохранив при этом соглашения для метода equals/compareTo. &#10;&#9;Проблема решается заменой наследования на композицию&#10;&#10;- порядок сравнения НЕважен&#10;&#9;- Чтобы добиться наилучшей производительности, вы должны в первую очередь сравнивать те поля, которые будут различаться с большей вероятностью, либо те, которыесравнивать проще.&#10;&#9;- если значение избыточного поля равнозначно суммарному описанию объекта в целом,то сравнение подобных полей позволит вам сэкономить на сравнениидействительных данных, если будет выявлено расхождение.&#10;&#10;- только если Не критичен перформанс то можно использовать Objects.hash&#10;&#10;- для сравнения полей вещественного типа используйте Float.compare, Double.compare&#10;&#10;- если есть неконсистентность с equals то ее нужно явно прописать в джавадоке&#10;&#10;-   нельзя вызывать исключения из equals и hashCode&#10;        - из equals лучше возвратить false чем вызвать исключение&#10;&#10;- на немутабельном типе можете закешировать хэш-код в самом этом объекте вместо того, чтобы вычислять его всякий раз заново, как только в нем появится необходимость&#10;&#10;-   при переопределении[некого моего класса] метода equals следует вызвать super.equals&#10;&#10;*/&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;&#10;&#10;/**&#10; * classic overrided method&#10; * equals&#10; *&#10; * &lt;pre&gt;{@code&#10; *&#10; *&#10; * }&lt;/pre&gt;&#10; */&#10;@Override&#10;public boolean equals(@Nullable final Object object )&#10;{&#10;&#10;if( this == object )&#10;&#9;{&#10;&#9;return true;&#10;&#9;}&#10;if( !( object instanceof ${NAME} ) )&#10;{&#10;return false;&#10;}&#10;&#10;var  tuple = (${NAME} ) object;&#10;&#10;if( !item1.equals( tuple.getItem1() ) )&#10;&#9;{&#10;&#9;return false;&#10;&#9;}&#10;if( !item2.equals( tuple.getItem2() ) )&#10;&#9;{&#10;&#9;return false;&#10;&#9;}&#10;if( !item3.equals( tuple.getItem3() ) )&#10;&#9;{&#10;&#9;return false;&#10;&#9;}&#10;if( !item4.equals( tuple.getItem4() ) )&#10;&#9;{&#10;&#9;return false;&#10;&#9;}&#10;if( !item5.equals( tuple.getItem5() ) )&#10;&#9;{&#10;&#9;return false;&#10;&#9;}&#10;if( !item6.equals( tuple.getItem6() ) )&#10;&#9;{&#10;&#9;return false;&#10;&#9;}&#10;if( !item7.equals( tuple.getItem7() ) )&#10;&#9;{&#10;&#9;return false;&#10;&#9;}&#10;if( !item8.equals( tuple.getItem8() ) )&#10;&#9;{&#10;&#9;return false;&#10;&#9;}&#10;if( !item9.equals( tuple.getItem9() ) )&#10;&#9;{&#10;&#9;return false;&#10;&#9;}&#10;return item10.equals( tuple.getItem10() );&#10;&#9;&#10;&#10;&#10;}&#10;&#10;&#10;&#10;/**&#10; * classic overrided method&#10; * hashCode&#10; *&#10; * &lt;pre&gt;{@code&#10; *&#10; *&#10; * }&lt;/pre&gt;&#10; */&#10;@Override&#10;public int hashCode()&#10;{&#10;&#10;return Objects.hash(Objects.hashCode( item1 ),Objects.hashCode( item2 ),Objects.hashCode( item3 ),Objects.hashCode( item4 ),Objects.hashCode( item5 ),Objects.hashCode( item6 ),Objects.hashCode( item7 ),Objects.hashCode( item8 ),Objects.hashCode( item9 ),Objects.hashCode( item10 ) );&#10;&#10;}&#10;&#10; &#10;&#10;&#10;&#10;&#10;&#10;/**&#10; * classic overrided method&#10; * compareTo&#10; *&#10; * &lt;pre&gt;{@code&#10; *&#10; *&#10; * }&lt;/pre&gt;&#10; */&#10;@Override&#10;&#10;&#10;public int compareTo(@NotNull final ${NAME} tuple )&#10;{&#10;var c = 0;&#10;&#10;c = item1.compareTo( tuple.getItem1() );&#10;&#10;if( c != 0 )&#10;&#9;{&#10;&#9;return c;&#10;&#9;}&#10;&#10;c = item2.compareTo( tuple.getItem2() );&#10;&#10;if( c != 0 )&#10;&#9;{&#10;&#9;return c;&#10;&#9;}&#10;&#10;c = item3.compareTo( tuple.getItem3() );&#10;&#10;if( c != 0 )&#10;&#9;{&#10;&#9;return c;&#10;&#9;}&#10;&#10;c = item4.compareTo( tuple.getItem4() );&#10;&#10;if( c != 0 )&#10;&#9;{&#10;&#9;return c;&#10;&#9;}&#10;c = item5.compareTo( tuple.getItem5() );&#10;&#10;if( c != 0 )&#10;&#9;{&#10;&#9;return c;&#10;&#9;}&#10;c = item6.compareTo( tuple.getItem6() );&#10;&#10;if( c != 0 )&#10;&#9;{&#10;&#9;return c;&#10;&#9;}&#10;c = item7.compareTo( tuple.getItem7() );&#10;&#10;if( c != 0 )&#10;&#9;{&#10;&#9;return c;&#10;&#9;}&#10;c = item8.compareTo( tuple.getItem8() );&#10;&#10;if( c != 0 )&#10;&#9;{&#10;&#9;return c;&#10;&#9;}&#10;&#10;c = item9.compareTo( tuple.getItem9() );&#10;&#10;if( c != 0 )&#10;&#9;{&#10;&#9;return c;&#10;&#9;}&#10;&#10;return item10.compareTo( tuple.getItem10() );&#10;}&#10;&#9;&#10;&#10;" description="equals for immutable objects" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="OLDmethod_toString" value="//////////////////////////////////////////////////////////////////////////////////&#10;//  implementations                              &#10;//////////////////////////////////////////////////////////////////////////////////&#10;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;    /* implementations&#10;    &#10;    (1) Base class AbstractList already has a good implementation of&#10;        - EQUALS,&#10;        - HASHCODE,&#10;        - shallow CLONE&#10;    &#10;    (2) Do not use default clone, use copy deep constructor and fabric&#10;    &#10;&#10;&#9;&#10;&#10;    */&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;&#10;/**&#10; * classic overrided method&#10; * toString&#10; *&#10; *      &#9;  - для больших объектов или объектов, состояние которых трудно представить в виде строки. &#10; *      &#9;  В таких случаях метод toString должен возвращать такие резюме, как «MyClass (1487536 peoples)»&#10; * &#10; * &lt;pre&gt;{@code&#10; *&#10; *&#10; * }&lt;/pre&gt;&#10; */&#10;@Override&#10;public String toString()&#10;&#9;{&#10;&#9;var addr=Integer.toHexString(System.identityHashCode(this));&#10;&#9;return &quot;${NAME}@&quot;+addr+ super.toString()  ;&#10;&#9;}   " description="class method toString" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="method public immutable / chisto" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/* public method&#10;&#9;&#10;&#9;0) перегенерировать javadoc MAC8+fixDocComment&#10;&#10;- covariance: this overrided method can return subclass unstead class:&#10;       resultSomeSuperclass f_method()&#10;       resultSomeSubclass   f_overrided_method()&#10;&#10;&#10;&#10;//      public privateFinal protectedPackage _package_ final &#10;//      throws Exception, VX_myxception &#10;//      @Override  &#10;&#10;&#10; *   - количество параметров должно быть не более 4-х, иначе:&#10; * &#9;- разбить метод на несколько (как например в NEW-SET-CALL для каждого параметра отдельный сетер)&#10; * &#9;- вынести группу параметров в value-класс (nested static) (helper class)&#10; * &#9;- все параметры зашить в паттерн билдер, где параметры можно присваивать по-очереди (так что билдер применим и на мутабельном объекте)&#10; *&#10; * &#9; * - в немутабельных классах используется функциональный подход: &#10; * &#9;- операции немутабельного класса могут возвращать новый немутабельный объект&#10; * &#9;например врзвращать немутабельный объект того же класса&#10; * &#10; * &#10;&#10;*/&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;/**&lt;pre&gt;&#10; *   public method description&#10; *&#10; * &#10; * {@code&#10; *           o.$f_method$(&quot;string&quot;);&#10; * }&#10; * &lt;/pre&gt;&#10; * &#10;&#10; *  @throws NullPointerException if argument nullable&#10; *  @throws IllegalArgumentException if argument empty &#10;&#10; */&#10;&#10;public Optional&lt;String&gt; $f_method$( final String string )&#10;{&#10;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*&#10;throw new VX_exception( &quot;vError&quot; );&#10;log_.debug   ( &quot;${PROJECT_NAME} ${PACKAGE_NAME} ${NAME}  f_test: &quot; );&#10;super.f_method(p_1);&#10;&#10;/генерирую runtime ошибки программирования &#10;throw new IllegalArgumentException(  );&#10;&#10;генерирую runtime ошибки выполнения метода &#10;throw new MyApplicationException( &quot;vError&quot; );&#10;throw new NoResult$f_method$Exception( &quot;vError&quot; ); &#10; &#10; &#10; &#10; &#10;  (*) для immutable objects and NEW-CALL pattern:&#10;        (1)свойство в конструкторе проверяем  -&gt; в итоговом вызове НЕ проверяем&#10;        Objects.requireNonNull( object.stringTwo );&#10;&#9;  &#10;&#10;  (*) для param receive strategy:&#10;        (1) Objects.requireNonNull(p_1);&#10;        (2) String p_2= (p_1 == null)? new String() : p_1;&#10; &#10; &#10; три варианта проверки входного аргумента&#10; 1) @NonNull   от LOMBOK&#10; 2) notBlank(string) notEmpty(collection)&#10; 3) optional&#10;&#10; */&#10;//&lt;/editor-fold&gt;&#10;&#10; &#10;if( string == null || string.isBlank()   )&#10;&#9;{&#10;&#9;logAtWarning_( &quot;string param must not ne null or empty&quot; );&#10;&#9;return Optional.empty();&#10;&#9;}&#10;&#10;log_( &quot;compute({})&quot;,string );&#10;&#10;return Optional.ofNullable( string );&#10;// todo postcondition check of output result&#10;}" description="for immutable classes" toReformat="false" toShortenFQNames="true">
    <variable name="f_method" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="OLDmethod protected" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/* protected method&#10;&#10;- covariance: this overrided method can return subclass unstead class:&#10;      resultSomeSuperclass f_method()&#10;      resultSomeSubclass   f_overrided_method()&#10;&#10;&#10;&#10;public privateFinal protectedPackage _package_ final &#10;throws Exception, VX_myxception &#10;@Override  &#10;*/&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;/**&#10; *   protected method description&#10; *   !CHANGE_ME_DESCRIPTION!&#10; *&#10; * &lt;pre&gt;{@code&#10; *&#10; * example 1&#10; *&#10; *           v_object.twoCompute();&#10; *&#10; * }&lt;/pre&gt;&#10; */&#10;protected  void    twoCompute()&#10;{        &#10;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*&#10;throw new VX_exception( &quot;vError&quot; );&#10;log_.debug   ( &quot;${PROJECT_NAME} ${PACKAGE_NAME} ${NAME}  f_test: &quot; ); &#10; &#10; &#10;  (*) для mutable objects and NEW-SET-CALL pattern:&#10;        свойство в конструкторе не проверяем -&gt; проверяем в итоговом вызове метода&#10;        в сетере даем возможность обнулить параметр  -&gt; потом в методе для него выставим дефолтное значение&#10;&#9; if (stringTwo==null) log_.info( &quot;Input parameter is null.&quot; );&#10;&#9; &#10;  (*) для immutable objects and NEW-CALL pattern:&#10;        (1)свойство в конструкторе проверяем  -&gt; в итоговом вызове НЕ проверяем&#10;        Objects.requireNonNull( object.stringTwo );&#10;&#10;&#10;  (*) для param receive strategy:&#10;        (1) Objects.requireNonNull(p_1);&#10;            (2) String p_2= (p_1 == null)? new String() : p_1;&#10;                 &#10; &#10; */&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10; &#10;return;&#10;} " description="protected method for mutable and immutable calsses" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="OLDmethod_compareTo" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/* equals and hashCode&#10;&#10;-  фундаментальная проблема эквивалентных отношений в объектно ориентированных языках. &#10;&#9;Не существует способа расширить класс, порождающий экземпляры, и добавить к нему компонент значения, сохранив при этом соглашения для метода equals/compareTo. &#10;&#9;Проблема решается заменой наследования на композицию&#10;&#10;- в compareTo порядок сравнения важен&#10;&#9;&#9;- Если у класса есть несколько значимых полей, порядок их сравнения критически важен. &#10;&#9;&#9;- Вы должны начать с самого значимого поля и затем следовать в порядке убывания значимости.&#10;&#10;&#10;-   при переопределении[некого моего класса] метода compareTo следует выбрать одну из двух стратегий&#10;&#9;1) не переопределять метод и сделать метод базового класса как final&#10;&#9;2) внутри обоих методов сделать проверку на абсолютное равенство типу сравниваемого класса, чтобы сравнение было симметрично для тех случаев когда сравниваются объект подкласса с объектом суперкласса&#10;&#9;3) можно вообще не переопределять этот метод а сортировать элементы используя Comparator, или использовать упорядоченные коллекции которым передается на вход Comparator (TreeSet, TreeMap, PriorityQueue) вместо Comparable элементов&#10;&#10;&#10;-   НЕЛЬЗЯ переопределять данный метод для МУТАБЕЛЬНЫХ классов основываясь на равенстве всех свойств&#10;        - тк как только одно из свойств изменится то равенство сразу потеряется&#10;        - также объект потеряется сразу в Tree-коллекциях  тк равенство объекта проверяется через compareTo&#10;-   для мутабельных классов следует переопределять данный метод отталкиваясь от равенства идентификатора выбранного для определения идентичности&#10;-   рекомендуется делать метод final, если будет сравниваться идентификатор выбранный для идентичности&#10; &#10;&#10;- не используйте операторы больше/меньше, для сравнения ВСЕХ примитивных типов используйте Double.compare, Float.compare,... или Comparator.comparingInt(&#10;&#10;&#10;- можно вызвать ClassCastException если я сочту что сравниваемся с объектом недопустимого подкласса&#10;&#10;- если есть неконсистентность с equals то ее нужно явно прописать в джавадоке&#10;&#10;- при попытке обратиться к нулевому объекту и так вызовется иксепшен при попытке обратиться к сравниваемому свойству&#10;&#10;- если сравниваемое поле не Comparable то я могу использовать для сравнения объект компаратора&#10;&#10;&#10;правила имплементации интерфейса&#10;&#9;- рефлексивность&#10;&#9;- отличие от null&#10;&#9;- симметрия: если изменить порядок сравнения двух объектов то ничего не должно поменяться&#10;&#9;- транзитивность&#10;&#9;- объекты, сравнение которых дает равенство, при сравнении с любым третьим объектом должны показывать одинаковый результат&#10;&#9;- consistent with equals&#10;&#10;&#10;*/&#10;//&lt;/editor-fold&gt;&#10;&#10;@Override" description="equals for immutable objects" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="method public mutable / for inheritance /with private helper" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*  &#10;  compute method&#10;&#10; *  1) no method args, because all inside props&#10; *&#10; *  2) количество параметров должно быть не более 4-х, иначе:&#10; *   &#9;- разбить метод на несколько (как например в NEW-SET-CALL для каждого параметра отдельный сетер)&#10; *   &#9;- вынести группу параметров в value-класс (nested static) (helper class)&#10; *   &#9;- все параметры зашить в паттерн билдер, где параметры можно присваивать по-очереди (так что билдер применим и на мутабельном объекте)&#10; *&#10; ** example 1&#10; *            - генерирую runtime ошибки программирования&#10; *            - генерирую runtime ошибки выполнения метода, если метод не вернет то что должен&#10; *&#10; *&#10; * example 2&#10; *&#10; *           v_obj.f_method(&quot;test&quot;);&#10; *&#10; * example 3&#10; *&#10; *           - covariance: this overrided method can return subclass unstead class:&#10; *                  resultSomeSuperclass f_method()&#10; *                  resultSomeSubclass   f_overrided_method()&#10; *&#10; *&#10; @throws NullPointerException if argument nullable&#10;&#10;&#10; три варианта проверки входного аргумента&#10; 1) @NonNull   от LOMBOK&#10; 2) notBlank(string) notEmpty(collection)&#10; 3) optional&#10; &#10; &#10; &#10;*/&#10;//&lt;/editor-fold&gt;&#10;&#10;/** {@inheritDoc}&#10; *&lt;pre&gt;&#10; *  compute method&#10; *      - for inheritance&#10; *&#10; *&#10; * {@code&#10; *&#10; *           o.$f_method$(&quot;string&quot;);&#10; *&#10; * }&#10; * &#10; * &lt;/pre&gt;&#10; &#10; @throws IllegalStateException if some object's property null or empty&#10; &#10; @implSpec  The method does'not call other public methods.&#10; @implNote  it is a wrapper for private compute_() method&#10; &#10; @return empty value if input argument empty  &#10; */&#10;public Optional&lt;String&gt; compute(final String string )&#10;{&#10;&#9;if( string == null || string.isBlank() || !isConsistent() )&#10;&#9;&#9;{&#10;&#9;&#9;logAtWarning_( &quot;string param must not ne null or empty&quot; );&#10;&#9;&#9;return Optional.empty();&#10;&#9;&#9;}&#10;&#9;&#10;&#9;log_( &quot;compute({})&quot;,string );&#10;&#9;&#10;&#9;return compute_(string);&#10;// todo postcondition check of output result&#10;}&#10;&#10;private Optional&lt;String&gt; compute_(final String string )&#10;{&#10;&#9;//assert !(string==null || string.isBlank()):&quot;Please put not blank string&quot;;&#10;&#9;&#10;&#9;return Optional.ofNullable( string );&#10;}" description="for mutable classes" toReformat="false" toShortenFQNames="true">
    <variable name="f_method" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="OLD method helper deep copy" value="&#10;private static final Supplier&lt; Gson &gt; gson_ =  Gson::new;&#10;&#10;//helper method: deep copy with google gson&#10;private static &lt; E  &gt; E deepCopyOf_(E   object ,Class&lt;?&gt; classOfObject)&#10;{&#10;assert object==null: &quot;Argument should not be null.&quot; ;&#10;&#10;Gson g = gson_.get();&#10;return  (E) g.fromJson( g.toJson( object ), classOfObject );&#10;}" description="for immutable classes" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="method private / chisto" value="&#10;&#10;private  void  $f_method$_(String string)&#10;{&#10;&#10;return ;&#10;} " description="private method for mutable and immutable calsses" toReformat="false" toShortenFQNames="true">
    <variable name="f_method" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="method public immutable MONO" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*  &#10;  compute method&#10;&#10; *  1) no method args, because all inside props&#10; *&#10; *  2) количество параметров должно быть не более 4-х, иначе:&#10; *   &#9;- разбить метод на несколько (как например в NEW-SET-CALL для каждого параметра отдельный сетер)&#10; *   &#9;- вынести группу параметров в value-класс (nested static) (helper class)&#10; *   &#9;- все параметры зашить в паттерн билдер, где параметры можно присваивать по-очереди (так что билдер применим и на мутабельном объекте)&#10; *&#10; ** example 1&#10; *            - генерирую runtime ошибки программирования&#10; *            - генерирую runtime ошибки выполнения метода, если метод не вернет то что должен&#10; *&#10; *&#10; * example 2&#10; *&#10; *           v_obj.f_method(&quot;test&quot;);&#10; *&#10; * example 3&#10; *&#10; *           - covariance: this overrided method can return subclass unstead class:&#10; *                  resultSomeSuperclass f_method()&#10; *                  resultSomeSubclass   f_overrided_method()&#10; *&#10; *&#10; @throws NullPointerException if argument nullable&#10;&#10;&#10; три варианта проверки входного аргумента&#10; 1) @NonNull   от LOMBOK&#10; 2) notBlank(string) notEmpty(collection)&#10; 3) optional&#10; &#10; &#10; &#10;*/&#10;//&lt;/editor-fold&gt;&#10;&#10;/**&lt;pre&gt; {@inheritDoc}&#10; *&#10; *  compute method&#10; *      - for inheritance&#10; *&#10; *&#10; * {@code&#10; *&#10; *           o.$f_method$(&quot;string&quot;);&#10; *&#10; * }&#10; * &lt;/pre&gt;&#10; * &#10; &#10; @throws IllegalStateException if some object's property null or empty&#10; &#10; @implSpec  The method does'not call other public methods.&#10; @implNote  it is a wrapper for private compute_() method&#10; &#10; @return empty value if input argument empty  &#10; */&#10;&#10;public Mono&lt;String&gt; draw( final Integer canvas )&#10;&#9;{&#10;&#9;if( canvas == null )&#10;&#9;&#9;return illegalArgumentMonoError( &quot;Canvas must not be empty&quot; );&#10;&#9;else if(  canvas  &lt; 0  )&#10;&#9;&#9;return illegalArgumentMonoError( &quot;Figure must be inside canvas&quot; );&#10;&#9;else&#10;&#9;&#9;return just( canvas ).flatMap( this::draw_ );&#10;&#9;// todo postcondition check of output result&#10;&#9;}&#10;&#10;private Mono&lt;String&gt; draw_( final Integer canvas )&#10;&#9;{&#10;&#9;&#10;&#9;return just( this );&#10;&#9;}" description="for mutable classes" toReformat="false" toShortenFQNames="true">
    <variable name="f_method" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="method public static" value="public static final List&lt;String&gt;    $f_method$(String string)&#10;&#9;{&#10;&#9;if( string == null || string.isBlank() || !isConsistent() )&#10;&#9;&#9;{&#10;&#9;&#9;logAtWarning( &quot;$f_method$: string param must not ne null or empty&quot; );&#10;&#9;&#9;return List.&lt;String&gt;of();&#10;&#9;&#9;}&#10;&#9;&#10;&#9;log_( &quot;$f_method$({})&quot;,string );&#10;&#9;&#10;&#9;var list=List.&lt;String&gt;of(string);&#10;&#9;assert !list.isEmpty()  : &quot;CCheck invariant - collection should not be empty.&quot; ;&#10;&#9;return list;&#10;&#9;} " description="SIMPLIEST" toReformat="false" toShortenFQNames="true">
    <variable name="f_method" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_CODE" value="true" />
    </context>
  </template>
</templateSet>