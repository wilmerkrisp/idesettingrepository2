<templateSet group="VV_class_new">
  <template name="newobj dynamic1" value="//example creates String object by &quot;java.lang.String&quot;&#10;@SuppressWarnings(&quot;unchecked&quot;)&#10;String v_2 = null;&#10;try&#10;&#9;{&#10;&#9;v_2 = (String) Class.forName( &quot;java.lang.String&quot; )&#10;&#9;                    .getDeclaredConstructor( new Class[] { String.class&#10;&#9;                                                           /*constructor argument types*/ } )&#10;&#9;                    .newInstance( &quot;test string&quot; );&#10;&#9;}&#10;catch( InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException | ClassNotFoundException p_e )&#10;&#9;{&#10;&#9;p_e.printStackTrace( );&#10;&#9;log_.error( &quot;VV_class main &quot; +p_e);&#10;&#9;}&#10;log_.debug( &quot;string:&quot; + v_2 );&#10;&#10;" description="new object by&quot;Name&quot;" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_EXPRESSION" value="true" />
      <option name="JAVA_STATEMENT" value="true" />
    </context>
  </template>
  <template name="newobj dynamic2" value="@SuppressWarnings(&quot;unchecked&quot;)&#10;$String$ v_input = &quot;teml&quot;;&#10;&#10;try&#10;&#9;{&#10;&#9;//throw new Exception( &quot;vError&quot; );&#10;&#9;&#10;&#9;$String$ v_output=($String$) v_input.getClass( )&#10;&#9;                         .getDeclaredConstructor( new Class[] { } )&#10;&#9;                         .newInstance( );&#10;&#9;&#9;&#10;&#9;&#9;&#10;&#9;&#9;&#10;&#9;}&#10;catch( InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException  p_e )&#10;&#9;{&#10;&#9;log_.error( &quot;mainclass main catch: &quot; + p_e );&#10;&#9;}&#10;&#10;&#10;" description="new object by variable / generic T p_input" toReformat="false" toShortenFQNames="true">
    <variable name="String" expression="classNameComplete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_EXPRESSION" value="true" />
      <option name="JAVA_STATEMENT" value="true" />
    </context>
  </template>
  <template name="newclass anonym" value="$inherited_from_abstractclassORinterface$ v_anon = new $inherited_from_abstractclassORinterface$() /*inherit from class OR interface*/&#10;&#9;{&#10;&#9;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;&#9;/*&#10;&#9;if super.constructor have params:&#10;&#9;&#9;new $inherited_from_abstractclassORinterface$(&quot;test string&quot;)&#10;&#9; */&#10;&#9;//&lt;/editor-fold&gt;&#9;&#10;&#9;&#10;&#9;&#10;&#9;&#10;&#9;//some NOT static property&#10;&#9;private String c_str;&#10;&#9;&#10;&#9;{&#10;&#9;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;&#9;/* some initializer (class name is unknown therefore NO CONSTRUCTOR)&#10;&#9;THIS of OUTER class is avialable&#10;&#9;&#9;$outerclass$.this.f_method(&quot;test&quot;);  or f_method(&quot;test&quot;); &#10;&#9;&#9;&#10;&#9;locals OUTER class FINAL variables is avialable&#9;                    &#10;&#9;&#9;p_1;        &#10;&#9;&#9;                                                                                                                                      &#10;&#9;use constructor of base class&#9;&#10;&#9;&#9;super(12); &#10;&#9;&#9;&#10;&#9;*/&#10;&#9;//&lt;/editor-fold&gt;&#10;&#9;&#10;&#9;&#10;&#9;c_str=new String( &quot;test string&quot; );&#10;&#9;}&#10;&#9;&#10;&#9;&#10;&#9;public void someInterfaceMethod(final String p_1)&#10;&#9;&#9;{&#10;&#9;&#9;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;&#9;&#9;/* some NOT static method&#10;&#9;&#9;throw new Exception( &quot;vError&quot; );&#10;&#9;&#9;&#10;&#9;&#9;THIS of OUTER class is avialable&#10;&#9;&#9;&#9;$outerclass$.this.f_method(&quot;test&quot;);  or f_method(&quot;test&quot;); &#10;&#9;&#9;&#9;&#10;&#9;&#9;locals OUTER class FINAL variables is avialable&#9;            &#10;&#9;&#9;&#9;p_1; &#10;&#9;&#9;&#10;&#9;&#9;use methods of base class&#9;             &#9;                                                                 &#10;&#9;&#9;&#9;super.method(12);                                                     &#9;&#9; &#10;&#9;&#9; &#10;&#9;&#9;(*)    Can I replace p_1 with default object?&#10;&#9;                String p_2= (p_1 == null)? new String() : p_1;&#9;&#10;&#9;&#9; */&#10;&#9;&#9;//&lt;/editor-fold&gt;&#10;&#9;&#9;&#10;&#9;&#9;&#10;&#9;&#9;Objects.requireNonNull( p_1 );&#10;&#9;&#9;&#10;&#9;&#9;method(p_1);&#10;&#9;&#9;$END$&#10;&#9;&#9;}&#10;&#9;};" description="class anonym" toReformat="false" toShortenFQNames="true">
    <variable name="inherited_from_abstractclassORinterface" expression="classNameComplete()" defaultValue="" alwaysStopAt="true" />
    <variable name="outerclass" expression="className()" defaultValue="" alwaysStopAt="false" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
      <option name="JAVA_EXPRESSION" value="true" />
      <option name="JAVA_STATEMENT" value="true" />
    </context>
  </template>
  <template name="newclass anonym&lt;&gt;" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*&#10;- this is the object and the class, NO  T &#10;- REPLACE ALL  T  ON THE CONCRETE CLASS&#10; &#10;- inherit from class OR interface&#10;&#10;&#10; */&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;&#10;$inherited_from_abstractclassORinterface$&lt;String&gt; v_anon = new $inherited_from_abstractclassORinterface$&lt;&gt;() &#10;&#9;{        &#10;&#9;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;&#9;/*&#10;&#9; if super.constructor have params:&#10;&#9;&#9;new $inherited_from_abstractclassORinterface$(&quot;test string&quot;)&#10;&#9; &#10;&#9; &#10;&#9; */&#10;&#9;//&lt;/editor-fold&gt;&#10;&#9;&#10;&#9;&#10;&#9;//some NOT static property&#10;&#9;private String c_str;&#10;&#9;&#10;&#9;{&#10;&#9;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;&#9;/* some initializer (class name is unknown therefore NO CONSTRUCTOR)&#10;&#9;THIS of OUTER class is avialable&#10;&#9;&#9;$outerclass$.this.f_method(&quot;test&quot;);  or f_method(&quot;test&quot;); &#10;&#9;&#9;&#10;&#9;locals OUTER class FINAL variables is avialable&#9;                    &#10;&#9;&#9;p_1;        &#10;&#9;&#9;                                                                                                                                      &#10;&#9;use constructor of base class&#9;&#10;&#9;&#9;super(12); &#10;&#9;&#9;&#10;&#9;*/&#10;&#9;//&lt;/editor-fold&gt;&#10;&#9;&#10;&#9;&#10;&#9;c_str=new String( &quot;test string&quot; );&#10;&#9;}&#10;&#9;&#10;&#9;&#10;&#9;public void/* T */ someInterfaceMethod(final  T  p_1)&#10;&#9;&#9;{&#10;&#9;&#9;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;&#9;&#9;/* some NOT static method&#10;&#9;&#9;throw new Exception( &quot;vError&quot; );&#10;&#9;&#9;&#10;&#9;&#9;THIS of OUTER class is avialable&#10;&#9;&#9;&#9;$outerclass$.this.f_method(&quot;test&quot;);  or f_method(&quot;test&quot;); &#10;&#9;&#9;&#9;&#10;&#9;&#9;locals OUTER class FINAL variables is avialable&#9;            &#10;&#9;&#9;&#9;p_1; &#10;&#9;&#9;&#10;&#9;&#9;use methods of base class&#9;             &#9;                                                                 &#10;&#9;&#9;&#9;super.method(12);                                                     &#9;&#9; &#10;&#9;&#9; &#10;&#9;&#10;&#9;&#9; */&#10;&#9;&#9;//&lt;/editor-fold&gt;&#10;&#9;&#9;&#10;&#9;&#9;&#10;&#9;&#9;method(p_1);&#10;&#9;&#9;$END$&#10;&#9;&#9;}&#10;&#9;};" description="class anonym&lt;&gt;" toReformat="false" toShortenFQNames="true">
    <variable name="inherited_from_abstractclassORinterface" expression="classNameComplete()" defaultValue="" alwaysStopAt="true" />
    <variable name="outerclass" expression="className()" defaultValue="" alwaysStopAt="false" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
      <option name="JAVA_EXPRESSION" value="true" />
      <option name="JAVA_STATEMENT" value="true" />
    </context>
  </template>
  <template name="newclass internal" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*&#10;&#10;      1) create outer class&#10;              $outerclass$                v_obj1 = new $outerclass$();&#10;&#10;      2) create PUBLIC inner class&#10;              $outerclass$.$newclassname$ v_obj2 = v_obj1.new $newclassname$();&#10;              or&#10;              SomeInterface               v_obj2 = v_obj1.new $newclassname$();&#10;&#10;      3) for inherited inner subclass&#10;              $outerclass$                v_obj1 = new $outerclass$();&#10;              VV_BASEINNERCLASS         v_objBASE = v_obj1.new VV_BASEINNERCLASS();;&#10;              $newclassname$ v_obj2 =     $newclassname$(v_objBASE);&#10;              &#10;&#10;&#10;      1) REAL multiple inheritance&#10;             I  from base class1&#10;             II like a lambda has access to the outer class2&#10;             -  and from interface&#10;&#10;      2) internal class has access to all PRIVATE props and methods of outer class&#10;&#10;      3) NO static props and methods inside internal class&#10;&#10;      4) internal class INSIDE CLASS can be private, public, protected, _package_&#10;      5) internal class INSIDE METHOD dont have public..&#10;      6) internal class INSIDE INTERFACE always PUBLIC STATIC (see template newclass3)&#10; &#10; &#10; */&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;/**&lt;pre&gt;    class internal&#10; * &#10; *      !CHANGE_ME_DESCRIPTION!&#10; * &#10; *{@code&#10; *              &#10;&#10; *              &#10; *              &#10; *                      &#10; * }&#10; &lt;/pre&gt;*/&#10;public class $newclassname$&#10;&#9;{&#10;&#9;&#10;&#9;&#10;&#9;//some property&#10;&#9;private String c_str;&#10;&#9;&#10; &#10;&#9;{&#10;&#9;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;&#9;/* some initializer (class name is unknown therefore NO CONSTRUCTOR)&#10;&#9;&#10;&#9;THIS of OUTER class is avialable&#10;&#9;&#9;$outerclass$.this.f_method(&quot;test&quot;);  or f_method(&quot;test&quot;); &#10;&#9;&#9;&#10;&#9;locals OUTER class FINAL variables is avialable&#9;                    &#10;&#9;&#9;p_1;        &#10;&#9;&#9;                                                                                                                                      &#10;  &#10;&#9;&#9;&#10;&#9;*/&#10;&#9;//&lt;/editor-fold&gt;&#10;&#9;&#10;&#9;&#10; &#9;c_str=new String( &quot;test string&quot; );&#10;&#9;}&#10;&#10;&#10;&#9;$newclassname$()&#10;&#9;&#9;{&#10;&#9;&#9;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;&#9;&#9;/* some constructor&#10;&#9;&#9;THIS of OUTER class is avialable&#10;&#9;&#9;&#9;$outerclass$.this.f_method(&quot;test&quot;);  or f_method(&quot;test&quot;); &#10;&#9;&#9;&#9;&#10;&#9;&#9;locals OUTER class FINAL variables is avialable&#9;                    &#10;&#9;&#9;&#9;p_1;        &#10;&#9;&#9; &#10;&#9;&#9; &#10;&#9;&#9; &#10;&#9;&#9; */&#10;&#9;&#9;//&lt;/editor-fold&gt;&#10;&#9;&#9;&#10;&#9;&#9;&#10; &#9;&#9;}&#10;&#9;&#10;&#9;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;&#9;/* FOR INHERITED inner subclass&#10;&#9;&#10;&#9;$newclassname$(VV_BASEINNERCLASS p_1)&#10;&#9;&#9;{&#10;&#9;&#9;p_1.super(p_1);&#10;&#9;&#9;}&#9; &#10;&#9; &#10;&#9; &#10;&#9; */&#10;&#9;//&lt;/editor-fold&gt;&#10;&#9;&#10;&#10;&#9;&#10;&#9;&#10;&#9; &#10;&#9;public void someInterfaceMethod(final String p_1)&#10;&#9;&#9;{&#10;&#9;&#9;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;&#9;&#9;/* some method&#10;&#9;&#9;throw new Exception( &quot;vError&quot; );&#10;&#9;&#9;&#10;&#9;&#10;&#9;&#9;THIS of OUTER class is avialable&#10;&#9;&#9;&#9;$outerclass$.this.f_method(&quot;test&quot;);  or f_method(&quot;test&quot;); &#10;&#9;&#9;&#9;&#10;&#9;&#9;locals OUTER class FINAL variables is avialable&#9;                    &#10;&#9;&#9;&#9;p_1;        &#10;&#9;&#9; &#10;&#9;&#9; &#10;&#9;&#9; &#10;&#9;&#9; */&#10;&#9;&#9;//&lt;/editor-fold&gt;&#10;&#9;&#9;&#10;&#9;&#9;&#10; &#9;&#9;this.method(p_1);&#10;&#9;&#9;$END$&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#10;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/* fabric method&#10;&#10;1) create outer class&#10;      $outerclass$                v_obj1 = new $outerclass$(); &#10;&#10;2a) create inner class&#10;      $outerclass$.$newclassname$ v_obj2 = v_obj1.getInternal();&#10;&#10;2b) or get ABSOLUTELY HIDDEN inner class behind interface&#10;      SomeInterface               v_obj2 = v_obj1.getInternal();&#10;&#10;&#10; &#10; */&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;/**                             fabric method: produce PRIVATE internal class&#10; * &lt;pre&gt;{@code&#10; *&#10; * }&lt;/pre&gt;&#10; */&#10;&#10;public $newclassname$ getInternal()&#10;&#9;{&#10;&#9;return new $newclassname$();&#10;&#9;}&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;" description="class internal" toReformat="false" toShortenFQNames="true">
    <variable name="newclassname" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="outerclass" expression="className()" defaultValue="" alwaysStopAt="false" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
      <option name="JAVA_EXPRESSION" value="true" />
      <option name="JAVA_STATEMENT" value="true" />
    </context>
  </template>
  <template name="newclass internal&lt;&gt;" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*&#10;1) create outer class&#10;      $outerclass$                v_obj1 = new $outerclass$();&#10;&#10;2) create PUBLIC inner class&#10;      $outerclass$.$newclassname$ v_obj2 = v_obj1.new $newclassname$();&#10;      or&#10;      SomeInterface               v_obj2 = v_obj1.new $newclassname$();&#10;&#10;3) for inherited inner subclass&#10;      $outerclass$                v_obj1 = new $outerclass$();&#10;      VV_BASEINNERCLASS         v_objBASE = v_obj1.new VV_BASEINNERCLASS();;&#10;      $newclassname$ v_obj2 =     $newclassname$(v_objBASE);&#10;              &#10;         &#10;              &#10;1) REAL multiple inheritance&#10;       I  from base class1&#10;       II like a lambda has access to the outer class2&#10;       -  and from interface&#10;&#10;2) internal class has access to all PRIVATE props and methods of outer class&#10;&#10;3) NO static props and methods inside internal class&#10;&#10;4) internal class INSIDE CLASS can be private, public, protected, _package_&#10;5) internal class INSIDE METHOD dont have public..&#10;6) internal class INSIDE INTERFACE always PUBLIC STATIC (see template newclass3)&#10; &#10; &#10; */&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;/** &lt;pre&gt; class internal withGENERIC&#10; *&#10; *      !CHANGE_ME_DESCRIPTION!&#10; * &#10; * {@code&#10; *              &#10;&#10; *              &#10; *              &#10; *                      &#10; * }&#10; * &lt;/pre&gt;&#10; */&#10;&#10;public class $newclassname$&lt; T  /* extends super VCG_&lt; T &gt; &amp; VIG_&lt; T &gt;*//* extends super VC_ &amp; VI_ *//* extends super VCG_&lt;String&gt; &amp; VIG_&lt;String&gt; */ &gt;&#10;&#9;{&#10;&#9;&#10;&#9;&#10;&#9;//some property&#10;&#9;private String c_str;&#10;&#9;&#10; &#9;{&#10;&#9;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;&#9;/* some initializer (class name is unknown therefore NO CONSTRUCTOR)&#10;&#9;&#10;&#9;THIS of OUTER class is avialable&#10;&#9;&#9;$outerclass$.this.f_method(&quot;test&quot;);  or f_method(&quot;test&quot;); &#10;&#9;&#9;&#10;&#9;locals OUTER class FINAL variables is avialable&#9;                    &#10;&#9;&#9;p_1;        &#10;&#9;&#9;                                                                                                                                      &#10;  &#10;&#9;&#9;&#10;&#9;*/&#10;&#9;//&lt;/editor-fold&gt;&#10;&#9;&#10; &#9;c_str=new String( &quot;test string&quot; );&#10;&#9;}&#10;&#10;&#9;//some constructor&#10;&#9;$newclassname$()&#10;&#9;&#9;{&#10;&#9;&#9;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;&#9;&#9;/* some constructor&#10;&#9;&#9;THIS of OUTER class is avialable&#10;&#9;&#9;&#9;$outerclass$.this.f_method(&quot;test&quot;);  or f_method(&quot;test&quot;); &#10;&#9;&#9;&#9;&#10;&#9;&#9;locals OUTER class FINAL variables is avialable&#9;                    &#10;&#9;&#9;&#9;p_1;        &#10;&#9;&#9; &#10;&#9;&#9; &#10;&#9;&#9; &#10;&#9;&#9; */&#10;&#9;&#9;//&lt;/editor-fold&gt;&#10;&#10;&#9;&#9;&#10; &#9;&#9;}&#10;&#9;&#10;&#9;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;&#9;/* FOR INHERITED inner subclass&#10;&#9; &#10;&#9;$newclassname$(VV_BASEINNERCLASS p_1)&#10;&#9;&#9;{&#10;&#9;&#9;p_1.super(p_1);&#10;&#9;&#9;}&#9; &#10;&#9; &#10;&#9; &#10;&#9; */&#10;&#9;//&lt;/editor-fold&gt;&#10;&#10;&#9;&#10;&#9;&#10;&#9;&#10;&#9;//some method&#10;&#9;public void someInterfaceMethod(final  T  p_1)&#10;&#9;&#9;{&#10;&#9;&#9;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;&#9;&#9;/* some method&#10;&#9;&#9;&#10;&#9;&#9;throw new Exception( &quot;vError&quot; );&#10;&#9;&#9;&#10;&#9;&#10;&#9;&#9;THIS of OUTER class is avialable&#10;&#9;&#9;&#9;$outerclass$.this.f_method(&quot;test&quot;);  or f_method(&quot;test&quot;); &#10;&#9;&#9;&#9;&#10;&#9;&#9;locals OUTER class FINAL variables is avialable&#9;                    &#10;&#9;&#9;&#9;p_1;         &#10;&#9;&#9; &#10;&#9;&#9; */&#10;&#9;&#9;//&lt;/editor-fold&gt;&#10;&#9;&#9;&#10;&#9;&#9;&#10; &#9;&#9;this.method(p_1);&#10;&#9;&#9;$END$&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*&#10;&#10;1) create outer class&#10;      $outerclass$                v_obj1 = new $outerclass$(); &#10;&#10;2a) create inner class&#10;      $outerclass$.$newclassname$ v_obj2 = v_obj1.getInternal();&#10;&#10;2b) or get ABSOLUTELY HIDDEN inner class behind interface&#10;      SomeInterface               v_obj2 = v_obj1.getInternal();&#10; &#10; &#10; */&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;/**                             fabric method: produce PRIVATE internal class&#10; * &lt;pre&gt;{@code&#10; *&#10; * }&lt;/pre&gt;&#10; */&#10;&#10;public $newclassname$&lt;String&gt; getInternal()&#10;&#9;{&#10;&#9;return new $newclassname$&lt;&gt;();&#10;&#9;}&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;" description="class internal&lt;&gt;" toReformat="false" toShortenFQNames="true">
    <variable name="newclassname" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="outerclass" expression="className()" defaultValue="" alwaysStopAt="false" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
      <option name="JAVA_EXPRESSION" value="true" />
      <option name="JAVA_STATEMENT" value="true" />
    </context>
  </template>
  <template name="newclass nested" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*&#10; &#10;1) create PUBLIC inner class&#10;      $outerclass$.$newclassname$ v_obj2 = new $outerclass$.$newclassname$();&#10;      or&#10;      SomeInterface  v_obj2              = new $outerclass$.$newclassname$();&#10;&#10;2) direct use static methods&#10;      $outerclass$.$newclassname$.someInterfaceMethod2(&quot;test&quot;); &#10; &#10; &#10;1)  internal class has access only to STATIC props and methods of outer class&#10;&#10;2)  can have static props and methods inside internal class &#10;&#10;3) internal class INSIDE INTERFACE always PUBLIC STATIC &#10; &#10; */&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;&#10;/**&lt;pre&gt;   class internal&#10; * &#10; *      !CHANGE_ME_DESCRIPTION!&#10; * &#10; * {@code&#10; *&#10;&#10; *              &#10; * }&#10; * &lt;/pre&gt;&#10; */ &#10;public static class $newclassname$&#10;&#9;{&#10;&#10;&#9;//some property&#10;&#9;private String c_str1;&#10;&#9;&#10;&#9;//some STATIC property&#10;&#9;private static String c_str2;&#10;&#9;&#10;&#9;//some initializer&#10;&#9;{&#10;&#9;//THIS of OUTER class NOT avialable&#10;&#9;c_str1=new String( &quot;test string&quot; );&#10;&#9;}&#10;&#9;&#10;&#9;//some STATIC initializer&#10;&#9;static&#10;&#9;&#9;{&#10;&#9;&#9;//STATIC properties and methods of outer class avialable &#10;&#9;&#9;c_str2=new String( &quot;test string&quot; );&#10;&#9;&#9;}&#10;&#9;&#10;&#9;//some constructor&#10;&#9;$newclassname$()&#10;&#9;&#9;{&#10;&#9;&#9;//THIS of OUTER class NOT avialable&#10;&#9;&#9;//STATIC properties and methods of outer class avialable &#10;&#9;&#9;}&#10;&#10;&#9;//some method&#10;&#9;public void someInterfaceMethod1(final String p_1)&#10;&#9;&#9;{&#10;&#9;&#9;//throw new Exception( &quot;vError&quot; );&#10;&#9;&#9;//THIS of OUTER class NOT avialable&#10;&#9;&#9;method(p_1);&#10;&#9;&#9;$END$&#10;&#9;&#9;}&#10;&#9;&#10;&#9;//some STATIC method&#10;&#9;public static void someInterfaceMethod2(final String p_1)&#10;&#9;&#9;{&#10;&#9;&#9;//STATIC properties and methods of outer class avialable &#10;&#9;&#9;staticmethod(p_1);&#10;&#9;&#9;$END$&#10;&#9;&#9;}&#10;}&#10;&#10;&#10;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*&#10; &#10;      2a) create inner class&#10;              $outerclass$.$newclassname$ v_obj2 = $outerclass$.getInternal();&#10;      2b) or get ABSOLUTELY HIDDEN inner class behind interface&#10;              SomeInterface               v_obj2 = $outerclass$.getInternal();&#10;&#10;&#10;&#10;&#10;&#10; &#10; &#10; */&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;/**                             STATIC fabric method: produce PRIVATE internal class&#10; * &lt;pre&gt;{@code&#10; *&#10; * }&lt;/pre&gt;&#10; */&#10;&#10;public static $newclassname$ getInternal()&#10;&#9;{&#10;&#9;return new $newclassname$();&#10;&#9;}&#10;" description="class nested / internal static" toReformat="false" toShortenFQNames="true">
    <variable name="newclassname" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="outerclass" expression="className()" defaultValue="" alwaysStopAt="false" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
      <option name="JAVA_EXPRESSION" value="true" />
      <option name="JAVA_STATEMENT" value="true" />
    </context>
  </template>
  <template name="newclass nested&lt;&gt;" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*&#10; &#10;1) create PUBLIC inner class&#10;      $outerclass$.$newclassname$ v_obj2 = new $outerclass$.$newclassname$();&#10;      or&#10;      SomeInterface  v_obj2              = new $outerclass$.$newclassname$();&#10;&#10;2) direct use static methods&#10;      $outerclass$.$newclassname$.someInterfaceMethod2(&quot;test&quot;); &#10; &#10; &#10;1)  internal class has access only to STATIC props and methods of outer class&#10;&#10;2)  can have static props and methods inside internal class &#10;&#10;3) internal class INSIDE INTERFACE always PUBLIC STATIC &#10; &#10; */&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;/**&lt;pre&gt;  class nested withGENERIC&#10; * &#10; * &#10; *      !CHANGE_ME_DESCRIPTION!&#10; * &#10; * {@code&#10; *&#10; &#10; *              &#10; * }&#10; &lt;/pre&gt;*/&#10;                                                              &#10;public static class $newclassname$&lt; T  /* extends super VCG_&lt; T &gt; &amp; VIG_&lt; T &gt;*//* extends super VC_ &amp; VI_ *//* extends super VCG_&lt;String&gt; &amp; VIG_&lt;String&gt; */ &gt;&#10;&#9;{&#10;&#10;&#9;//some property&#10;&#9;private String c_str1;&#10;&#9;&#10;&#9;//some STATIC property&#10;&#9;private static String c_str2;&#10;&#9;&#10;&#9;//some initializer&#10;&#9;{&#10;&#9;//THIS of OUTER class NOT avialable&#10;&#9;c_str1=new String( &quot;test string&quot; );&#10;&#9;}&#10;&#9;&#10;&#9;//some STATIC initializer&#10;&#9;static&#10;&#9;&#9;{&#10;&#9;&#9;//STATIC properties and methods of outer class avialable &#10;&#9;&#9;c_str2=new String( &quot;test string&quot; );&#10;&#9;&#9;}&#10;&#9;&#10;&#9;//some constructor&#10;&#9;$newclassname$()&#10;&#9;&#9;{&#10;&#9;&#9;//THIS of OUTER class NOT avialable&#10;&#9;&#9;//STATIC properties and methods of outer class avialable &#10;&#9;&#9;}&#10;&#10;&#9;//some method&#10;&#9;public void someInterfaceMethod1(final  T  p_1)&#10;&#9;&#9;{&#10;&#9;&#9;//throw new Exception( &quot;vError&quot; );&#10;&#9;&#9;//THIS of OUTER class NOT avialable&#10;&#9;&#9;method(p_1);&#10;&#9;&#9;$END$&#10;&#9;&#9;}&#10;&#9;&#10;&#9;//some STATIC method&#10;&#9;public static void someInterfaceMethod2(final  T  p_1)&#10;&#9;&#9;{&#10;&#9;&#9;//STATIC properties and methods of outer class avialable &#10;&#9;&#9;staticmethod(p_1);&#10;&#9;&#9;$END$&#10;&#9;&#9;}&#10;}&#10;&#10;&#10;//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*&#10; &#10;2a) create inner class&#10;      $outerclass$.$newclassname$ v_obj2 = $outerclass$.getInternal();&#10;2b) or get ABSOLUTELY HIDDEN inner class behind interface&#10;      SomeInterface               v_obj2 = $outerclass$.getInternal();&#10;&#10;&#10;&#10;&#10;&#10; &#10; &#10; */&#10;//&lt;/editor-fold&gt;&#10;/**                             STATIC fabric method: produce PRIVATE internal class&#10; * &lt;pre&gt;{@code&#10; *&#10; * }&lt;/pre&gt;&#10; */&#10;&#10;public static $newclassname$ getInternal()&#10;&#9;{&#10;&#9;return new $newclassname$();&#10;&#9;}&#10;" description="class nested / internal static &lt;&gt;" toReformat="false" toShortenFQNames="true">
    <variable name="newclassname" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="outerclass" expression="className()" defaultValue="" alwaysStopAt="false" />
    <context>
      <option name="JAVA_DECLARATION" value="true" />
      <option name="JAVA_EXPRESSION" value="true" />
      <option name="JAVA_STATEMENT" value="true" />
    </context>
  </template>
  <template name="newobj dynamic3[]" value="@SuppressWarnings(&quot;unchecked&quot;)&#10;$String$[] v_arr = ($String$[]) java.lang.reflect.Array&#10;&#9;                            .newInstance( $v_input$.getClass( )&#10;&#9;                                               .getComponentType( ) ,&#10;&#9;                                          $v_input$.length );&#10;" description="new object by variable[] / generic T[] p_input" toReformat="false" toShortenFQNames="true">
    <variable name="String" expression="classNameComplete()" defaultValue="" alwaysStopAt="true" />
    <variable name="v_input" expression="arrayVariable()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_EXPRESSION" value="true" />
      <option name="JAVA_STATEMENT" value="true" />
    </context>
  </template>
  <template name="newobj imm new.try.catch" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*&#10;automaticly close resource&#10;EXC UP during CLOSE object&#10;but not during NEW&#10;catch (final 1Exception | 2Exception  p_exception)&#10; &#10; &#10; */&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;&#10;try($v_obj$/* ; */)&#10;&#9;{&#10;&#9;&#10;&#9;$SELECTION$&#10;&#9;&#9;&#10;&#9;}&#10;catch( final VX_onClose_exception p_exception )&#10;{&#10;throw p_exception;&#10;}&#10;catch( final Exception p_exception )&#10;{&#10;throw new VX_box_exception( &quot; cant create or close object &quot;+$v_obj$ , p_exception );&#10;}" description="new object-value IMMUTABLE close resource" toReformat="false" toShortenFQNames="true">
    <variable name="v_obj" expression="variableOfType(&quot;java.lang.AutoCloseable&quot;)" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_EXPRESSION" value="true" />
      <option name="JAVA_STATEMENT" value="true" />
    </context>
  </template>
  <template name="newobj imm try(new)catch" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*&#10;automaticly close resource&#10;EXC UP during creation/close object &#10;catch (final 1Exception | 2Exception  p_exception) &#10; &#10; &#10; */&#10;//&lt;/editor-fold&gt;&#10;&#10;&#10;&#10;try($classname$ v_obj = new $classname$()/* ; */)&#10;&#9;{&#10;&#9;&#10;&#9;$SELECTION$&#10;&#9;&#9;&#10;&#9;//log_.debug( &quot;succesfull creation object &quot; + v_obj );&#10;&#9;}&#10;catch( final VX_onCreation_exception|VX_onClose_exception p_exception )&#10;&#9;{&#10;&#9;throw p_exception;&#10;&#9;}&#10;catch( final Exception p_exception )&#10;&#9;{&#10;&#9;throw new VX_box_exception( &quot; cant create or close object $classname$&quot; , p_exception );&#10;&#9;}" description="new object-value IMMUTABLE close resource" toReformat="false" toShortenFQNames="true">
    <variable name="classname" expression="classNameComplete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_EXPRESSION" value="true" />
      <option name="JAVA_STATEMENT" value="true" />
    </context>
  </template>
  <template name="newobj1" value="var $var$ = new $classname$();&#10;$END$" description="new object" toReformat="false" toShortenFQNames="true">
    <variable name="classname" expression="classNameComplete()" defaultValue="" alwaysStopAt="true" />
    <variable name="var" expression="suggestVariableName()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_EXPRESSION" value="true" />
      <option name="JAVA_STATEMENT" value="true" />
    </context>
  </template>
  <template name="newobj2 =" value="new $classname$($END$)&#10;" description="PARAM=new object" toReformat="false" toShortenFQNames="true">
    <variable name="classname" expression="classNameComplete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_EXPRESSION" value="true" />
      <option name="JAVA_STATEMENT" value="true" />
    </context>
  </template>
  <template name="newobj3 &lt;&gt;" value="var $var$ = new $classname$&lt;$typee$&gt;();&#10;$END$" description="new object GENERIC class" toReformat="false" toShortenFQNames="true">
    <variable name="classname" expression="classNameComplete()" defaultValue="" alwaysStopAt="true" />
    <variable name="typee" expression="classNameComplete()" defaultValue="" alwaysStopAt="true" />
    <variable name="var" expression="suggestVariableName()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_EXPRESSION" value="true" />
      <option name="JAVA_STATEMENT" value="true" />
    </context>
  </template>
  <template name="newobj4 &lt;&gt;" value="new $classname$&lt;$type$&gt;($END$)&#10;" description="PARAM=new object GENERIC class" toReformat="false" toShortenFQNames="true">
    <variable name="classname" expression="classNameComplete()" defaultValue="" alwaysStopAt="true" />
    <variable name="type" expression="classNameComplete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_EXPRESSION" value="true" />
      <option name="JAVA_STATEMENT" value="true" />
    </context>
  </template>
  <template name="newobj1 weak" value="//&lt;editor-fold desc=&quot;.&quot;&gt;&#10;/*&#10; (!) dont use STRONG references like this:&#10;        var r = new $classname$();&#10;        var r= weakRef.get();   &#10;        &#10; (!) create object stright inside constructor of weak reference&#10;        WeakReference (new Objectt());&#10;        r.get().someMethod();&#10; &#10; */&#10;//&lt;/editor-fold&gt;&#10;var r = new WeakReference&lt;$classname$&gt;(new $classname$());&#10;System.gc();&#10;System.out.println( &quot;Main main &quot; +r.get()); // = null after garbage collection&#10;$END$" description="new object / weak reference" toReformat="false" toShortenFQNames="true">
    <variable name="classname" expression="classNameComplete()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_EXPRESSION" value="true" />
      <option name="JAVA_STATEMENT" value="true" />
    </context>
  </template>
</templateSet>